
$hash_SizesLattice={}
class SizesLattice
	attr_accessor :size
	def self.bottom ;	self[0];				end
	def self.empty  ;	self[0];  			end
	def self.default;	self[0];			  end
	def self.top	  ; self[1.0/0.0];	end
	def self.[](a)
		return $hash_SizesLattice[a] if $hash_SizesLattice[a]
		l=self.new
		l.size=a
		$hash_SizesLattice[a]=l
	end
	alias_method :==,:equal?
	def |(a)
		SizesLattice[ [size,a.size].min ]
	end
	def seqjoin(a)
		SizesLattice[ size+a.size ]
	end
	def inspect; "SizesLattice[#{size}]";end
end

class FirstLattice
	attr_accessor :ary
  def self.empty;    self[];  		 end
  def self.bottom;   self[];			 end
	
	def |(a)
		self.class[*(ary|a.ary)]
	end
	def -(a)
		self.class[*(ary-a.ary)]
	end
	def &(a)
		self.class[*(ary&a.ary)]
	end
	def seqjoin(a)
    (self-self.class.empty)|a
  end

	def cases(first)
		ary.map{|c| "case #{c}:;"}*""
	end
	def inspect
		self.class.to_s+ary.inspect
	end
end

$hash_CharLattice={}
class CharLattice < FirstLattice
	def self.[](*ary)
		return $hash_CharLattice[ary] if $hash_CharLattice[ary]
		c=CharLattice.new
		c.ary=ary
		$hash_CharLattice[ary]=c
	end
	alias_method :==,:equal?
	def self.top;	         CharLattice[[0,255]] ;end
	def self.default;	     top|empty            ;end
	def cchar(c)
		return "'#{c.chr}'" if c.chr.inspect.size==3 && c.chr.inspect!='"\'"' && c.ord < 128
		"UC(#{c.ord})"
	end
  def cases(first)
    ary.map{|c| "case #{cchar(c[0])} ... #{cchar(c[1])}:;"}*""
  end
	def ~
		first=0
		nary=[]
		((normalize.ary-[])+[[256,256]]).each{|beg,en|
			nary<<[first,beg-1] if first<=beg-1
			first=en+1
		}
		CharLattice[*nary]
	end
	def &(a)
		r= ~(~self | ~a)
		r
	end
	def |(a)
		c=CharLattice.new
		c.ary=ary+a.ary
		c.normalize
	end
	def normalize
		nary=[]
		special=[]
		ary=@ary
		if ary.size>0
			first,last=*ary.sort[0]
			(ary.sort+[[257,257]]).each{|beg,en|
				if beg<=last+1
					last=[last,en].max
				else
					nary<<[first,last]
					first,last=beg,en
				end
			}
		end
		CharLattice[*(nary+special)]
	end
end

$hash_ClasLattice={}
class ClasLattice < FirstLattice
  attr_accessor :ary
  def self.[](*ary)
		ary=ary.uniq.sort_by{|a| a.inspect}
		return $hash_ClasLattice[ary] if $hash_ClasLattice[ary]
    c=ClasLattice.new
    c.ary=ary
    $hash_ClasLattice[ary]=c
  end
	alias_method :==,:equal?
  def self.top;     ClasLattice[Object];  end
	def self.default;	top|empty;            end
end
class First_Dataflow < Amethyst
	def initialize
    @depend=Oriented_Graph.new
    @vals=Hash.new(lattice.bottom)
		@visited={}
  end

	def analyze(e)
    @active={}
    @activea=[e]
		while el=@activea.pop
			@active.delete(el)
      val=getvalue(el)
      if val!=@vals[el]
        @vals[el]=val
        @depend.edges[el].each{|d| addactive(d)}
      end

		end
		@vals[e]
	end 
	def depends(e)
		@depend.add(e,@vis) unless @depend.edges[e].include?(@vis)
		if !@visited[e]
			@visited[e]=true
			addactive(e)
		end
	end
	def addactive(e)
    if !@active[e]
      @active[e]=true
      @activea<<e
    end
  end

	def empty?(el)
		#puts "emp",$sizedf.analyze(el).size,el.inspect
		
		$sizedf.analyze(el).size==0
	end
end
class Sizes_Dataflow < First_Dataflow
	def lattice
		SizesLattice
	end
	def empty?(el)
		true
	end
end

class Switch_Dataflow < First_Dataflow
  def firstchar(s)
	  return lattice.empty if s==""
    s=s[0].bytes.to_a[0]
		lattice[[s,s]]
  end
	def regchar(s)
		return ~regchar("/["+s[3...-2]+"]/") if s[2]==?^ 
		chars=[]
		s=s[2...-2]
		i=0
		while i<s.size
			c=s[i].bytes.to_a[0]
			if s[i+1]==?-
				chars<<[c,s[i+2].bytes.to_a[0]]
				i+=3
			elsif s[i]==?\\
				c=eval('"'+s[i,2]+'"')[0].bytes.to_a[0]
				chars<<[c,c]
				i+=2
			else
				chars<<[c,c]
				i+=1
			end
		end
		lattice[*chars]
	end
	def lattice
		CharLattice
	end
end

class ClasSwitch_Dataflow < First_Dataflow
	def lattice
		ClasLattice
	end
end
amethyst First_Dataflow {
	value =  .:x  {depends(x);#puts "#{x.inspect} #{@@vals[x].inspect}"; 
@@vals[x]}


	root = .:x analyze(x)
	
	first = Switch[ [ .:p  value:v {p.is_a?(lattice)? p & v : v}:vals[] ]* {vals.inject(:|)} ]
				| Or[value*:{it.inject(:|)}]
				| Seq[{lattice.empty}:val (.:el {el}=>value:nev {val.seqjoin(nev)}:val  (~{empty?(el)} break | empty) )*   .* {val}]
				| Many[value:val {val|lattice.empty} ]
				| Apply[ :name &{Compiler.grammars[@clas]&&Compiler.grammars[@clas].rules[name]}  { Compiler.grammars[@clas].rules[name].body}=>value ]
				| Switch[value*:{it.inject(:|)}]
	      | Bind[ value] 
				| (Act|CAct|Local|Result|Cut|Stop)[.* {lattice.empty} ]
				| .:el {empty?(el) ? lattice.top|lattice.empty : lattice.top}

	 getvalue(v) = {@@vis=v; v}=>first
}  			

amethyst Sizes_Dataflow < First_Dataflow {
	first = Apply[( ["_seq"] CAct[.:str] {lattice[str.size]} 
								| ["regch" | "clas" | "anything"] .* {lattice[1]}
								| ["fails"] {lattice.top}
								)]
			  | super
}

amethyst Switch_Dataflow < First_Dataflow{
	first = Apply[( ["_seq"  ] CAct[.:str] {firstchar(str)}
								| ["regch" ] Act[.:str]  {regchar(str)}
								| ["anything" ] {lattice.top}
								| ["fails"] {lattice.bottom}
							  )]
				| super
}

amethyst ClasSwitch_Dataflow < First_Dataflow{
  first = Apply[ ["clas"] CAct[.:cls] {lattice[cls]}]
        | super
}

class Detect_First< Traverser_Clone2
	def empty?(s)	
		$sizedf.analyze(s).size==0
	end
end

class Detect_Switch < Detect_First
	def initialize
		$sizedf=Sizes_Dataflow.new
		$sizedf.parse(:root,[])
	end
	def first(s)
		if !@switchdf
			@switchdf=Switch_Dataflow.new
			@switchdf.parse(:root,[])
		end
		r=@switchdf.analyze(s)
		r
	end
end

class Detect_ClasSwitch < Detect_First
	def first(s)
		if !@switchdf
			@switchdf=ClasSwitch_Dataflow.new
			@switchdf.parse(:root,[])
		end
		r=@switchdf.analyze(s)
		return (r|ClasLattice.top)-ClasLattice.empty if empty?(s)
		return r
	end
	def assume(str)
	end
	def child(par,chld)
		 #par,chld=eval(par.to_s),eval(chld.to_s)
		 is_child=(par<=chld)
		 assume("#{par.to_s}<=#{chld.to_s}") if is_child
		 is_child
	end
	def includes(ary,i,p)
		i.times{|ii|
			s=true
			p.ary.each{|f| s=false unless child(f,ary[ii])}
			return false if s
		}
		p.ary.each{|f| return true if child(ary[i],f) || child(f,ary[i])}
		return false
	end
	def classswitch(ary,first,ary3)
		@no=(@no||0)+1
		#TODO perfect hash
		init="Hash.new{|h,k|\n"
		ary.each_with_index{|c,i| init<< "next h[k]=#{i} if k<=#{c}\n"}
		init+="}\n"
		Switch[{:header=>"VALUE switchhash#{@name}#{@no};",:init=>"switchhash#{@name}#{@no}=rb_eval_string(#{init.inspect});#{gc_mark_var("switchhash#{@name}#{@no}")}" ,:act=>"FIX2LONG(rb_hash_aref(switchhash#{@name}#{@no},rb_obj_class(ame_curobj(self))))",:first=>first,:ary=>ary3}]
	end
	def topsort(a)
		a=a.uniq.sort_by{|a| a.to_s}
		g=Oriented_Graph.new
		a.each{|u| a.each{|v| g.add(u,v) if child(v,u) || (!child(u,v)&& u.to_s>v.to_s)}}
	 	g.topo_order
	end
end

amethyst Detect_First < Traverser_Clone2 {
	itrans =   (Grammar[ {@@name=@name} {$rules={};@rules.each{|r| $rules[r.name]=r}} @rules=>[ Rule[root]*:rules ] {@rules=rules} @self] | .)*

	root = traverse
}

amethyst Detect_Switch < Detect_First {
	visit =  Apply[ ["regch"] Act[.*] {first(@self)}:firs {s=Switch[{:act=>"*ame_curstr(self)",:ary=>[[firs,Apply["anything"]],[~firs,Apply["fails"]]]}]}]
				|  Apply[ ["_seq"] CAct[.:str] 
                  {first(@self)}:firs {s=Switch[{:act=>"*ame_curstr(self)",:ary=>[[firs,Seq[Apply["anything"],Apply["_seq",CAct[str[1..-1]]]]],[~firs,Apply["fails"]]]}]}]

				|  Apply[ ["fails"] {@self} ]
				|  Many[ traverse:t first(t):firs &{!empty?(@self) && firs!=CharLattice.top} {s=Switch[{:act=>"*ame_curstr(self)",:ary=>[[firs,Many[t]],[~firs,Apply["fails"]]]}] }]
				|	 Apply[ .*  {first(@self)}:firs &{!empty?(@self) && firs!=CharLattice.top} {s=Switch[{:act=>"*ame_curstr(self)",:ary=>[[firs,@self],[~firs,Apply["fails"]]]}] }]
				| Seq[ traverse_item*=>[combine_seq([])] ]
				| Or[ (traverse_item)*:items {false}:aswitch {items.each{|i| aswitch=true if i.is_a?(Switch)}}
							( &{!aswitch} {Or[*items]} 
							|  {items}=>[ combine_or([[CharLattice.top,[]]]) ]
							)
						]
				
 combine_seq(prefix) = (Act|CAct|Bind):s combine_seq(prefix+[s])
 										 | Switch[ .* @ary:ary ] .*:rest { Switch[{:act=>"*ame_curstr(self)",:ary=>ary.map{|p,a| [p,Seq[*(prefix+[a]+rest)]]}}] }
					 	         | .*:ary {Seq[*(prefix+ary)]}

 combine_or(list) = Switch[.* @ary:ary] {[]}:newlist
                           {list.each{|p,a| ary.each{|p2,a2| newlist << [p&p2,a+[a2]] if p&p2!=CharLattice.bottom}}}
                           combine_or(newlist)
                  | .:n {list.map{|p,a| [p,a+[n]]}}:newlist                                  
                           combine_or(newlist)
								  | eof {Switch[{:act=>"*ame_curstr(self)",:ary=>list.map{|p,a| [p,Or[*a].dup.normalize]}}]}
}

class ClasSwitch
	def self.[](*ary)
		init="Hash.new{|h,k|\n"
    ary.each_with_index{|c,i| init<< "next h[k]=#{i} if k<=#{c}\n"}
    init+="}\n"
	
		first= ary.map{|k,v| k}.inject(:|)
		init
		alts=[]
		first.ary.each{|a|
		}
		Switch[{:header=>"VALUE switchhash#{@name}#{$swno};",:init=>"switchhash#{@name}#{$swno}=rb_eval_string(#{init.inspect});#{gc_mark_var("switchhash#{@name}#{$swno}")}" ,:act=>"FIX2LONG(rb_hash_aref(switchhash#{@name}#{$swno},rb_obj_class(ame_curobj(self))))",:ary=>ary3}]
	end
end

amethyst Detect_ClasSwitch < Detect_First {
	visit = Apply[ ["clas"] .:clas            {ClasSwitch[[ClasLattice[clas],Apply["anything"]],[ClasLattice[Object],Apply["fails"]]] }]
				| Apply[ ["fails"] {@self} ]
				| Apply[ .* first(@self):firs &{!empty?(@self) && firs!=CharLattice.top} {ClasSwitch[[firs,@self],[~firs,Apply["fails"]]]   }]  
}

