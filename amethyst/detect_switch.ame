Anything=Consts.new("Anything")
Empty   =Consts.new("Empty"   )

$hash_SizesLattice={}
class SizesLattice
	attr_accessor :size
	def self.bottom ;	self[0];				end
	def self.empty  ;	self[0];  			end
	def self.default;	self[0];			  end
	def self.top	  ; self[1.0/0.0];	end
	def self.[](a)
		return $hash_SizesLattice[a] if $hash_SizesLattice[a]
		l=self.new
		l.size=a
		$hash_SizesLattice[a]=l
	end
	alias_method :==,:equal?
	def |(a)
		SizesLattice[ [size,a.size].min ]
	end
	def seqjoin(a)
		SizesLattice[ size+a.size ]
	end
	def inspect; "SizesLattice[#{size}]";end
end

class FirstLattice
	attr_accessor :ary
  def self.empty;    self[Empty];  end
  def self.bottom;   self[];			 end
	
	def |(a)
		self.class[*(ary|a.ary)]
	end
	def -(a)
		self.class[*(ary-a.ary)]
	end
	def &(a)
		self.class[*(ary&a.ary)]
	end
	def seqjoin(a)
    return self unless self.ary.include?(Empty)
    (self-self.class.empty)|a
  end

	def cases(first)
		ary.map{|c| c=="default" ? "default:;" : "case #{c}:;"}*""
	end
	def inspect
		self.class.to_s+ary.inspect
	end
end

$hash_CharLattice={}
class CharLattice < FirstLattice
	def self.[](*ary)
		return $hash_CharLattice[ary] if $hash_CharLattice[ary]
		c=CharLattice.new
		c.ary=ary
		$hash_CharLattice[ary]=c
	end
	alias_method :==,:equal?
	def self.top;	         CharLattice[[0,255]] ;end
	def self.default;	     top|empty            ;end
	def cchar(c)
		#return "UC('\\'')" if c==?'
		"UC(#{c.ord})"
	end
  def cases(first)
    ary.map{|c| c=="default" ? "default:;" : "case #{cchar(c[0])} ... #{cchar(c[1])}:;"}*""
  end
	def ~
		first=0
		nary=[]
		((normalize.ary-[Empty])+[[256,256]]).each{|beg,en|
			nary<<[first,beg-1] if first<=beg-1
			first=en+1
		}
		CharLattice[*nary]
	end
	def &(a)
		r= ~(~self | ~a)
		r
	end
	def |(a)
		c=CharLattice.new
		c.ary=ary+a.ary
		c.normalize
	end
	def normalize
		nary=[]
		special=[]
		ary=@ary
		[Empty,Anything,"default"].each{|s|
			special<<s if ary.include?(s)
			ary.delete(s)
		}
		if ary.size>0
			first,last=*ary.sort[0]
			(ary.sort+[[257,257]]).each{|beg,en|
				if beg<=last+1
					last=[last,en].max
				else
					nary<<[first,last]
					first,last=beg,en
				end
			}
		end
		CharLattice[*(nary+special)]
	end
end

$hash_ClasLattice={}
class ClasLattice < FirstLattice
  attr_accessor :ary
  def self.[](*ary)
		ary=ary.uniq.sort_by{|a| a.inspect}
		return $hash_ClasLattice[ary] if $hash_ClasLattice[ary]
    c=ClasLattice.new
    c.ary=ary
    $hash_ClasLattice[ary]=c
  end
	alias_method :==,:equal?
  def self.top;     ClasLattice[Object];  end
	def self.default;	top|empty;            end
end
class First_Dataflow < Amethyst
	def initialize
    @depend=Oriented_Graph.new
    @vals=Hash.new(lattice.bottom)
		@visited={}
  end

	def analyze(e)
    @active={}
    @activea=[e]
		while el=@activea.pop
			@active.delete(el)
      val=getvalue(el)
      if val!=@vals[el]
        @vals[el]=val
        @depend.edges[el].each{|d| addactive(d)}
      end

		end
		@vals[e]
	end 
	def depends(e)
		@depend.add(e,@vis) unless @depend.edges[e].include?(@vis)
		if !@visited[e]
			@visited[e]=true
			addactive(e)
		end
	end
	def addactive(e)
    if !@active[e]
      @active[e]=true
      @activea<<e
    end
  end

	def empty?(el)
		#puts "emp",$sizedf.analyze(el).size,el.inspect
		
		$sizedf.analyze(el).size==0
	end
end
class Sizes_Dataflow < First_Dataflow
	def lattice
		SizesLattice
	end
	def empty?(el)
		true
	end
end

class Switch_Dataflow < First_Dataflow
  def firstchar(s)
	  return lattice.empty if s==""
    s=s[0].bytes.to_a[0]
		lattice[[s,s]]
  end
	def regchar(s)
		return ~regchar("/["+s[3...-2]+"]/") if s[2]==?^ 
		chars=[]
		s=s[2...-2]
		i=0
		while i<s.size
			c=s[i].bytes.to_a[0]
			if s[i+1]==?-
				chars<<[c,s[i+2].bytes.to_a[0]]
				i+=3
			elsif s[i]==?\\
				c=eval('"'+s[i,2]+'"')[0].bytes.to_a[0]
				i+=2
			else
				chars<<[c,c]
				i+=1
			end
		end
		lattice[*chars]
	end
	def lattice
		CharLattice
	end
end

class ClasSwitch_Dataflow < First_Dataflow
	def lattice
		ClasLattice
	end
end
amethyst First_Dataflow {
	value =  .:x  {depends(x);puts "#{x.inspect} #{@@vals[x].inspect}"; 
@@vals[x]}


	root = .:x analyze(x)
	
	first =	Switch[&{@first.is_a?(lattice)} .* {@first}]
				| Switch[ [ .:e (&{e.ary!=["default"]} value:vals[]|.) ]* {vals.inject(:|)} ]
				| Seq[{lattice.empty}:val (.:el {el}=>value:nev {puts "#{val.inspect} #{nev.inspect} #{val.seqjoin(nev).inspect} #{el.inspect}";}
				{val.seqjoin(nev)}:val  (~{empty?(el)} break | empty) )*   .* {val}]
				| Many[value:val {val|lattice.empty} ]
				| Or[value*:{it.inject(:|)}]
				| Switch[value*:{it.inject(:|)}]
	      | Bind[ value] 
				| (Act|CAct|Local|Result|Cut|Stop)[.* {lattice.empty} ]
				| . {lattice.default}

	 getvalue(v) = {@@vis=v; v}=>first
}  			

amethyst Sizes_Dataflow < First_Dataflow {
	first = Apply[( ["_seq"] CAct[.:str] {lattice[str.size]} 
								| ["regch" | "clas" | "anything"] .* {lattice[1]}
								)]
			  | super
}

amethyst Switch_Dataflow < First_Dataflow{
	first = Apply[( ["_seq"  ] CAct[.:str] {firstchar(str)}
								| ["regch" ] Act[.:str]  {regchar(str)}
								| ["anything" ] {lattice.top}
							  )]
				| Apply[ :name &{Compiler.grammars[@clas]&&Compiler.grammars[@clas].rules[name]}  { Compiler.grammars[@clas].rules[name]}=>value ]
				| super
}

amethyst ClasSwitch_Dataflow < First_Dataflow{
  first = Apply[ ["clas"] CAct[.:cls] {lattice[cls]}]
				| Apply[ :name &{Compiler.grammars[@clas]&&Compiler.grammars[@clas].rules[name]}  { Compiler.grammars[@clas].rules[name]}=>value ]
        | super
}

class Detect_First< Traverser_Clone2
end

class Detect_Switch < Detect_First
	def initialize
		$sizedf=Sizes_Dataflow.new
		$sizedf.parse(:root,[])
	end
	def empty?(s)	
		$sizedf.analyze(s).size==0
	end
	def first(s)
		if !@switchdf
			@switchdf=Switch_Dataflow.new
			@switchdf.parse(:root,[])
		end
		r=@switchdf.analyze(s)
		r|= CharLattice.empty if empty?(s)
		r
	end
	def intersects(ar,el)
		return true if (ar.ary & [Empty,Anything]) != []
		return true if (el.ary & [Empty,Anything]) != []
		return true if el.ary.include?("default") || ar.ary.include?("default")
		return (ar & el).ary !=[]
	end
end

class Detect_ClasSwitch < Detect_First
	def first(s)
		if !@switchdf
			@switchdf=ClasSwitch_Dataflow.new
			@switchdf.parse(:root,[])
		end
		r=@switchdf.analyze(s)
		return (r|ClasLattice.top)-ClasLattice.empty if r.ary.include?(Empty)
		return r
	end
	def assume(str)
	end
	def child(par,chld)
		 #par,chld=eval(par.to_s),eval(chld.to_s)
		 is_child=(par<=chld)
		 assume("#{par.to_s}<=#{chld.to_s}") if is_child
		 is_child
	end
	def includes(ary,i,p)
		i.times{|ii|
			s=true
			p.ary.each{|f| s=false unless child(f,ary[ii])}
			return false if s
		}
		p.ary.each{|f| return true if child(ary[i],f) || child(f,ary[i])}
		return false
	end
	def classswitch(ary,first,ary3)
		@no=(@no||0)+1
		#TODO perfect hash
		init="Hash.new{|h,k|\n"
		ary.each_with_index{|c,i| init<< "next h[k]=#{i} if k<=#{c}\n"}
		init+="}\n"
		Switch[{:header=>"VALUE switchhash#{@name}#{@no};",:init=>"switchhash#{@name}#{@no}=rb_eval_string(#{init.inspect});#{gc_mark_var("switchhash#{@name}#{@no}")}" ,:act=>"FIX2LONG(rb_hash_aref(switchhash#{@name}#{@no},rb_obj_class(ame_curobj(self))))",:first=>first,:ary=>ary3}]
	end
	def topsort(a)
		a=a.uniq.sort_by{|a| a.to_s}
		g=Oriented_Graph.new
		a.each{|u| a.each{|v| g.add(u,v) if child(v,u) || (!child(u,v)&& u.to_s>v.to_s)}}
	 	g.topo_order
	end
end

amethyst Detect_First < Traverser_Clone2 {
	itrans =   (Grammar[ {@@name=@name} {$rules={};@rules.each{|r| $rules[r.name]=r}} @rules=>[ Rule[root]*:rules ] {@rules=rules} @self] | .)*

	root = traverse
}
def unempty(s)
	s.ary.include?(Empty) ? CharLattice.top	: s
end


amethyst Detect_Switch < Detect_First {
	visit = Or[ {CharLattice[]}:ary2 {[]}:ary3 {[]}:els
		(traverse_item:e &{first(e)} {e}:els[] {ary2|=first(e)})* &eof
		{ary2}:firs
		{ary2=ary2.ary.map{|el|  [Anything,Empty].include?(el) ? "default" : el}.uniq}
		&{ary2.size>1}
		{Or[*els]}:new_or
		&{new_or.is_a?(Or)}
		{firs=unempty(firs)}
		{@@cases=[firs]} {new_or}=>split 
		{@@cases.each{|ee|e=ee
			ary3<<[e,predicate(e,new_or)]
		}}
		{ary3=ary3.group_by{|a,b| b}.map{|y,v| [v.map{|k,val| k}.inject(:|),v[0][1]]}.sort_by{|el| el.inspect}}
		{ary3<<[CharLattice["default"],Apply["fails"]] unless ary2.include?("default")}
    &{ary3.size>1}
		{s=Switch[{:act=>"*ame_curstr(self)",:first=>firs,:ary=>ary3}];puts s.inspect;
		s}
	]
	
	split = Seq[ split*]
				| Or[ split* ]
				| Bind[ split ]
				| .:el first(el):f {@@cases=@@cases.map{|c| [c&f,c&~f]}.flatten.select{|x| x.ary.size>0}.uniq_by{|x|x.ary.inspect} }
	
	predicate(chr,p) = &{chr.ary[0]=="default"} {p}
										| &{!intersects(first(p),chr)} {Placeholder}
                    |  {p}=>( Seq[ .:e predicate(chr,e):f .*:rest {Seq[*([f]+rest)]} ]
														| Or[ (.:e predicate(chr,e))*:ary {Or[*ary]} ]
														| Switch[.*{
																 nary=p.ary
                                 nary=nary.select{|o,v| intersects(o,chr)} if p.first.is_a?(CharLattice)
                                 nary=nary.map{|o,v| [o,predicate(chr,v)]}.select{|o,v| v!=Placeholder}
                                 Switch[{:act=>p.act,:first=>p.first,:defs=>p.defs,:ary=>nary}]
                              }]
														| . 
														)
}

amethyst Detect_ClasSwitch < Detect_First {
	visit = Or[ {ClasLattice.bottom}:ary2 {[]}:ary3 {[]}:els
 		(traverse_item:e &{first(e)} {e}:els[] {ary2|=first(e)})* &eof
		{ary2}:firs
		{ary2=topsort(ary2.ary+[Object])}
		&{ary2.size>1}
		{Or[*els]}:new_or
    {	ary2.each_index{|i|
      	ary3<<[i,predicate(ary2,i,new_or)]
		}}
    {ary3=ary3.map{|o,v| v==Placeholder ? [o,Apply["fails"]] : [o,v]}}

		{ary3=ary3.group_by{|a,b| b}.map{|y,v| [v.map{|k,val| k}.sort_by{|el| el.inspect},v[0][1]]}.sort_by{|el| el.inspect}}
		{ary3=ary3.map{|o,v| [ClasLattice[*o],v]}}
	  {c=classswitch(ary2,firs,ary3);puts c.inspect;
     c}
	]

  predicate(clas,i,p) = &{clas[i]=="default"} {p}
											| &{!includes(clas,i,first(p))} {Placeholder}	
											|	{p}=>( Seq[ .:e predicate(clas,i,e):f .*:rest {Seq[*([f]+rest)]} ]
														 | Or[ (.:e predicate(clas,i,e))*:ary {Or[*ary]} ]
									  				 | Apply[ .:name &{name=="clas"} CAct[.:match] &{child(clas[i],match)&&clas[i]==match} {Apply["anything"]}] 
 										  			 | Bind[ @name:name .:exp {predicate(clas,i,exp)}:expr  {Bind[name,expr]}]
											  		 | .
												  	 )
}

