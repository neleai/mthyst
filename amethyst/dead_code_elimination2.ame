amethyst Dead_Code_Detector2 < Traverser {
	root = @this=>Rule[{@@edges=Oriented_Graph.new ; @@marked=[_Local("_result")]}  traverse {@@edges.reachable(@@marked)}:reachable {@reachable=reachable} @this]
	
	visit = Apply[:name vars_in:var traverse:this] ->  @@marked +=var;this
				| Pass[@var=>vars_in:var {@@marked+=var} traverse]
				| Act[ traverse:this {@@marked<<this if @pred} 
							 @ary=>[vars_in]:var ] -> var.each{|v| @@edges.add(v,this); @@edges.add(this,v);} ;@@marked<<this if v.is_a? Global; this
				| Set[@name:v   traverse:this @expr=>vars_in:var ] -> var.each{|w| @@edges.add(v,w)};this
				| Result[@vars=>[vars_in]:var traverse:this] -> var.each{|w| @@edges.add(this,w) } ; this
				
				vars_in={ary=[]}
								( Global[ @this:ary[] .*]
								| Act[ @this:ary[] .*]
								| Result[ @this:ary[] ]
								| Strin[ vars_in:ary[] ]
								| Args[ vars_in:ary[] ]
								| Set[ @name=>vars_in:ary[] ]
								| Local[:name @this:ary[] ]
								| anything
								)* -> ary
}

amethyst Dead_Code_Deleter2 < Traverser{
		root = @this=>Rule[ @reachable:{@@reachable=it} traverse]

		visit = Act[@this:this .*] -> @@reachable[this] ? this : Act[]
					| Set[@name:name traverse @expr:expr @this:this] -> @@reachable[name] ? this : expr
					| Result[@this:this] ->@@reachable[this] ? this : Act[]
}

amethyst Constant_Propagator2 < Traverser {
}

amethyst Communize_Or2 < Traverser {
	root = traverse
	
	visit = Or[ Seq[traverse]+:ands eof
							{common=ands[0].size
								ands.each{|a| 0.upto(common){|n| (common=[common,n].min ;next) if a[n].to_yaml!=ands[0][n].to_yaml}}
								commn=ands[0].ary[0,common]
								o=[]
								ands.each{|a| o<< Seq[{:ary=>a.ary[common,a.size-common]}] unless common==a.size	}
	            	Seq[{:ary=>(commn+[Or[{:ary=>o}]])}]
							}
            ]
}

amethyst Move_Assignments2 < Traverser {
	root=traverse 
	
	visit = Set[@name:name traverse @expr:expr @append:append {expr}=>move(append,name) ]

	move(append,name) = Or[ move(append,name)*:ary ] @Or
								| Seq[ (:el (&eof {el}=>move(append,name) | {el}) )*:ary ] @Seq
								| Pass[@var:var @to=>move(append,name):to @enter:enter] @Pass
								| anything:{_Set(name,it,append)}
}
