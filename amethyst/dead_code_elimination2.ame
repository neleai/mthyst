amethyst Dead_Code_Detector2 < Traverser {
	root = @this=>Rule[{@@edges=Oriented_Graph.new ; @@marked=[]} {@@bnding=@bnding} traverse {@@edges.reachable(@@marked)}:reachable {@reachable=reachable} @this]
	
	visit = Apply[:name vars_in:var{@@marked+=var} traverse]
				| Pass[@var=>vars_in:var {@@marked+=var} traverse]
				| Many[  @o=>vars_in:var {@@marked+=var} traverse]
				| Act[ traverse:this {@@marked<<this if @pred} 
							 @ary=>[vars_in]:var ] -> var.each{|v| @@edges.add(v,this); @@edges.add(this,v);}; this
				| Set[@name=>vars_in:v {v=v[0]}   traverse:this @expr=>vars_in:var ] -> var.each{|w| @@edges.add(v,w)};this
				| Result[@vars=>[vars_in]:var traverse:this] -> var.each{|w| @@edges.add(this,w) } ; this
				
				vars_in={ary=[]}
								( Global[ @this:ary[]  {@@marked<<@this} .*]								
								| Act[ @this:ary[] .*]
                | Key[ @this:ary[]    {@@marked<<@this} .*]
								| Result[ @this:ary[] ]
								| Strin[ vars_in:ary[] ]
								| Args[ vars_in:ary[] ]
								| Set[ @name=>vars_in:ary[] ]
								| Local[:name {@@marked<<@this if name=="_result"} @this:ary[] ]
								| anything
								)* -> ary
}

amethyst Dead_Code_Deleter2 < Traverser{
		root = @this=>Rule[ @reachable:{@@reachable=it} traverse {@reachable=nil} @this]

		visit = Act[@this:this .*] -> @@reachable[this] ? this : Act[]
					| Set[@name:name traverse @expr:expr @this:this] -> @@reachable[name] ? this : expr
					| Result[@this:this] ->@@reachable[this] ? this : Act[]
          | Local[.* @this:this] ->@@reachable[this] ? this : Act[]
}

amethyst Constant_Propagator2 < Traverser {
}

amethyst Communize_Or2 < Traverser {
	root = traverse
	
	visit = Or[ Seq[traverse]+:ands eof
							{common=ands[0].size
								ands.each{|a| 0.upto(common){|n| (common=[common,n].min ;next) if a[n].to_yaml!=ands[0][n].to_yaml}}
								commn=ands[0].ary[0,common]
								o=[]
								ands.each{|a| o<< Seq[{:ary=>a.ary[common,a.size-common]}] unless common==a.size	}
	            	Seq[{:ary=>(commn+[Or[{:ary=>o}]])}]
							}
            ]
}
amethyst Communize_Or3 < Traverser {
	root = traverse
	visit = Or[ Seq[traverse]+:ands eof {
							com=[]
							last=ands.shift
							ands.each{|a|
								if last[0].to_yaml==a[0].to_yaml
									last=Seq[last[0],Or[Seq[*last[1..(-1)]],Seq[*a[1..(-1)]]]]
								else
									com<<last
									last=a
								end
							}
							com<<last
							@ary=com
							@this
					} ]
}

amethyst Move_Assignments2 < Traverser {
	root=traverse 
	
	visit = Set[@name:name traverse @expr:expr @append:append {expr}=>move(append,name) ]

	move(append,name) = Or[ move(append,name)*:ary ] @Or
								| Seq[ (:el (&eof {el}=>move(append,name) | {el}) )*:ary ] @Seq
								| Pass[@var:var @to=>move(append,name):to @enter:enter] @Pass
								| anything:{_Set(name,it,append)}
}
