amethyst Dead_Code_Detector < AmethystOptimizer {

	trans = Rule[@name:name {@@edges=Oriented_Graph.new ; @@marked=[]}  @args=>args:args @body=>trans @body:body @locals:locals {@@edges.reachable(@@marked)}:reachable ] @Rule
				| Apply[:name vars_in:var {@@marked+=var} ]
				| Pass[@var=>vars_in:var {@@marked+=var} @to=>trans]
				| Act[ @self:this {@@marked<<this if @pred} 
							 vars_in:var ] -> var.each{|w| @@edges.add(w,this); @@edges.add(this,w)}
				| Set[@name=>vars_in:v {v=v[0]}  @expr=>trans @expr=>vars_in:var  ] -> var.each{|w| @@edges.add(v,w)}
				| Result[@vars=>[vars_in]:var @self:v] -> var.each{|w| @@edges.add(v,w) }
				| super 
				
				vars_in = {ary=[]} 
								( Global[ @self:ary[] {@@marked<<@self} .*]
								| Act[ @self:ary[] .*]
								| Key[ @self:ary[]    {@@marked<<@self} .*]
								| Exp[ trans ]
								| Result[ @self:ary[] ]
								| Strin[ vars_in:ary[] ]
								| Args[ vars_in:ary[] ]
								| Set[ @name=>vars_in:ary[] ]
								| Local[:name {@@marked<<@self if name=="_result"} @self:ary[] ]
								| anything
								)* -> ary
}

amethyst Dead_Code_Deleter < AmethystOptimizer{
		trans = Rule[ @name:name  @reachable:{@@reachable=it} @args=>args:args @body=>trans:body  @locals:locals ] @Rule
					| Act[@self:this .*] -> @@reachable[this] ? this : Act[]
					| Set[@name:name @expr=>trans:expr @append:append] ->@@reachable[name] ? _Set(name,expr,append) : expr
					| Result[@self:this] ->@@reachable[this] ? this : Act[]
					| Local[.* @self:this] ->@@reachable[this] ? this : Act[]
					| super
}


amethyst Communize_Or < AmethystOptimizer {
	trans = Or[ &(Seq[ trans:first  .*] ) Seq[ trans:fst &{first.isomorphic(fst)} trans*:rest {Seq[{:ary=>rest}]}:ary[]  ]* ] -> Seq[first ,Or[{:ary=>ary}] ]
	| super
}

amethyst Move_Assignments < AmethystOptimizer {
	trans = Set[@name:name @expr=>trans:expr @append:append {expr}=>move(append,name) ]
				| super

	move(append,name) = Or[ move(append,name)*:ary ] @Or
								| Seq[ .*:ary {ary[-1]}=>move(append,name):moved {@@x;ary[-1]=moved} ] @Seq
								| Pass[@var:var @to=>move(append,name):to @enter:enter] @Pass
								| anything:{_Set(name,it,append)}
}
