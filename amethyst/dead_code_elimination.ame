class Oriented_Graph
	def add(v,w)
		puts ("#{v} #{w}")
	end
end

amethyst Dead_Code_Detector < AmethystOptimizer {

	trans = Rule[@name:name {@@edges=Oriented_Graph.new ; @@marked=[Variable["result"]]}  @args=>args:args @body=>trans:body @locals:locals {puts @@marked.inspect}] @Rule
				| Apply[:name vars_in:var ] -> @@marked +=var
				| Act[ @pred=>_false vars_in:var] -> var.each{|v| var.each{|w| @@edges.add(v,w)}}
				|	Act[ @pred=>_true  vars_in:var] -> @@marked+=var
				| Set[@name:v   @expr=>trans @expr=>vars_in:var  ] -> var.each{|w| @@edges.add(v,w)}
				| super 
				
				vars_in = {ary=[];puts @@input.item.inspect} 
								(Variable[ @this:ary[] .*]
								| Args[ vars_in:ary[] ]
								| Act[ vars_in:ary[] ]
								| Set[ @name=>vars_in:ary[] ]
								| anything
								)* -> ary
}

amethyst Communize_Or < AmethystOptimizer {
	trans = Or[ &(And[ trans:first  .*] ) And[ trans:fst &{first.isomorphic(fst)} trans*:rest {And[{:ary=>rest}]}:ary[]  ]* ] -> And[first ,Or[{:ary=>ary}] ]
	| super
}

amethyst Move_Assignments < AmethystOptimizer {
	trans = Set[{puts @@input.src.inspect} @name:name @expr=>trans:expr {expr}=>move(@append,name) ]
				| super

	move(append,name) = Or[ move(append,name)*:ary ] @Or
								| And[ (:el (&eof {el}=>move(append,name) | {el}) )*:ary ] @And
								| Enter[@var:var @to=>move(append,name):to @enter:enter] @Enter
								| anything:{_Set(name,it,append)}
}
