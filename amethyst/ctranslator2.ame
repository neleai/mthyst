amethyst AmethystRBTranslator < Traverser{
}

class AmethystCTranslator < Amethyst 
	def addcallback(cb)
		@cbno||=0
		@cbno+=1
		n="#{@rulename}_cb#{@cbno}"
		@callbacks[n]=cb
		n
	end
	def bget(s)
		"rb_hash_aref(bind,ID2SYM(rb_intern(\"#{s}\")))"
		"BGET(#{s})"
	end
	def bset(s,e)
		"rb_hash_aset(bind,ID2SYM(rb_intern(\"#{s}\")),#{e})"
		"BSET(#{s},#{e})"
	end
	def iget(s)
		"rb_ivar_get(self,rb_intern(\"@#{s}\"))"
		"IGET(#{s})"
	end
	def iset(s,e)
		"rb_ivar_set(self,rb_intern(\"@#{s}\"),#{e})"
		"ISET(#{s},#{e})"
	end
	def label(s)
		@lno=(@lno||0)+1
		"#{s}#{@lno}"
	end
	def mktable(r)
		@ruletable={}
		r.each{|e| @ruletable[e.name]=e}
	end
end

amethyst AmethystCTranslator < Amethyst {
	transfn = trans:t -> "proc{#{t}}"
	rbtrans = Local[.* {"bind[:#{@desc}]"}]
					| Args[rbtrans*:a] -> a*""
					| Array[rbtrans*:a] -> a*""
		      | Strin[rbtrans*:a] -> a*""
    		  | Exp[transfn:t ] -> t
		      | Key[@name:name] -> "@src.#{name}"
      		| Global[:name] -> "@#{name}"
		      | .


	rbcode = {"class #{@@grammar} < #{@@parent}\n"}:s
	{@@callbacks.to_a}=>[([:k rbtrans:v]   {"def #{k}(bind)\n#{v}\nend\n"})*:x ]
	{s+=x*""}
	{s+="\nend"; "rb_eval_string(#{s.inspect});"}
	
	trans =  Grammar[ {@@grammar=@name;@@parent=@parent} {@@faillabel="fail"} {@@callbacks={}} {mktable(@rules)} {@@header=[]} @rules=>[trans*]:t rbcode:rbcode
				    { s="#include \"cthyst.h\"\nVALUE cls_#{@name};\n"
							s<<@@header*"\n"
							s<<t*"\n"
        		  s<<"\nvoid Init_#{@name}(){ cls_#{@name}=rb_define_class(\"#{@name}\",rb_const_get(rb_cObject,rb_intern(\"#{@@parent}\"))); 
failobj=rb_eval_string(\"FAIL\");
#{@rules.map{|r| "rb_define_method(cls_#{@name},\"#{r.name}\",#{@name}_#{r.name},#{r.args.size});"}*"\n" }
#{rbcode}
}"
							s } ]
				|  Rule[@name:name {@@rulename=name} @body=>trans:body  { h="VALUE #{@@grammar}_#{name}(VALUE self #{@args.size.times.map{|i| ",VALUE a#{i}"}})" 
						@@header<<h+";"
						h+"{VALUE bind=rb_hash_new(); #{@args.size.times.map{|i| bset(@args[i].desc,"a#{i}")+";"}} int x;VALUE arg0,arg1,arg2,arg3;\n#{body}\nreturn #{bget(Local["_result",@bnding].desc)};\nfail: return failobj; }" } ]
				| Act[ .*:{addcallback(@pred ? ["(",it,") || FAIL"]:it)}:cbno {"#{bset("it","CALL(#{cbno},1,bind)")}; #{@pred ? "FAILTEST(#{@@faillabel});" :"" }"} ]
				| Apply[:name (.:{addcallback(it)}*):args 
            failwrap(" #{args.size.times.map{|a|"arg#{a}=CALL(#{args[a]},1,bind);"}} #{bset("it",(@@ruletable[name] ? "#{@@grammar}_#{name}(self" : "CALL(#{name},#{args.size}")+ "#{args.size.times.map{|a|",arg#{a}"}})")};")]
				| Seq[ trans*:t {t*""} ]
				| Set[&{@append==true} @expr=>trans:e {"#{e} ;if(#{bget(@name[0])}==Qnil) #{bset(@name[0],"rb_ary_new()")}; CALL(_append,2,#{bget(@name[0])},#{bget("it")});" } ]			
				| Set[ @expr=>trans:e {"#{e}\n #{bset(@name.desc,bget("it"))}; " } ]
				| Or[ {label("accept")}:accept {@@faillabel}:fail {label("oldinput")}:oldinput {[label("alt")]}:alts
					 ( &(.) {alts<<label("alt")} rw(alts[-1],`trans`))*:t
					 {s="VALUE #{oldinput}=#{iget("input")};\n"}
           {t.size.times{|i| s<<"#{alts[i]}: #{iset("input",oldinput)};if (#{iget("cut")}!=Qnil) goto #{fail};\n #{t[i]} \n#{iset("cut","Qnil")};goto #{accept};\n"}}
           {"#{s}  #{alts[-1]}:  #{iset("input",oldinput)}; goto #{fail};\n #{accept}:;\n"}
					]
				| Many[ {label("break")}:brk {label("oldinput")}:oldinput
						rw(brk,`trans:t`)
						{"VALUE #{oldinput}; while(1){#{oldinput}=#{iget("input")}; #{t} } #{brk}: #{iset("input",oldinput)}; "}
					]
				| Lookahead[ {label("accept")}:accept {label("reject")}:reject {label("oldinput")}:oldinput 
										 rw(reject,`trans:t`) 
										 {"VALUE #{oldinput}=#{iget("input")};\n #{t} x=1; goto #{accept};  #{reject}: x=0; #{accept}: #{bset("it","Qnil")}; #{iset("input",oldinput)}; if (x==#{@neg ? 1 : 0}) goto #{@@faillabel};"} ]
				| Local[ .* { bset("it",bget(@desc))+";" } ]
				| Result[ @args=>rbtrans:argss  { s="#{@name}.create(#{argss} {#{@vars.map{|l| ":#{l[0]}=>bind[:#{l.desc}]" }.sort*","} })"
					cbno=addcallback(s)
					"#{bset("it","CALL(#{cbno},1,bind)")};"
				} ]
				| Pass[ label("pass"):pass label("oldinput"):oldinput label("oldsrc"):oldsrc label("success"):success label("fail"):fail
						rw(pass,`@to=>trans:to`)
					{  "VALUE #{oldinput}=#{iget("input")};  VALUE #{oldsrc}=#{iget("src")}; int #{fail}=0;
 #{iset("src",@enter ? "rb_ary_new3(1,#{iget(@var[0])})" : iget(@var[0]))}; #{iset("input","INT2FIX(0)")};
 #{t}
	if (CALL(eof,0)==failobj) goto #{pass};
	goto #{success};
	#{pass}: #{fail}=1;
	#{success}: #{iset("src",oldsrc)}; #{iset("input",oldinput)};
	if(#{fail}) goto #{@@faillabel};
" }
					]
	failwrap(s) = {"#{s} FAILTEST(#{@@faillabel});" }

	rw(word,prc) = {@@faillabel}:rwo {@@faillabel=word } apply(prc):x {@@faillabel=rwo; x }
}
