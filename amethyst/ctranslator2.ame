
class AmethystCTranslator < Amethyst 
  def addcallback2(cb)
    return @rcallbacks[cb] if @rcallbacks[cb]
    n="#{@grammar}_#{signature(cb)}"
    i=1
    i+=1 while @callbacks[n+(i>1 ? i.to_s : "")]
    n=n+i.to_s if i>1
    @rcallbacks[cb]=n
    @callbacks[n]=cb
    n
  end
  def desc(s)
    return @locls[s.desc] if @locls[s.desc]
    @locls[s.desc]=@locls.size
  end
  def bget(s)
    cm=s[0]
    s=desc(s)
    return "bind_aget(bind,#{s}/*#{cm}*/)"
  end
  def bset(s,e)
    cm=s[0]
    s=desc(s)
    return "bind_aset(bind,#{s}/*#{cm}*/,#{e})"
  end
  def rbbget(s)
    "bind[#{desc(s)}]"
  end
  def symb(str)
    str=str.gsub("@","_at_");
    sy="sy_#{str}"
    @header<<"static VALUE #{sy};"
    @init<<"#{sy}=rb_intern(#{str.inspect});"
    sy
  end
  def iget(s)
    "rb_ivar_get(self,#{symb("@#{s}")})"
  end
  def iset(s,e)
    "rb_ivar_set(self,#{symb("@#{s}")},#{e})"
  end
  def resetlabels
    @labels=Hash.new(0)
  end
  def label(s)
    @labels[s]+=1
    "#{s}#{@labels[s]}"
  end
  def mktable(r)
    @ruletable={}
    r.each{|e| @ruletable[e.name]=e}
  end
  def rbcall(name,args)
    "rb_funcall(self,#{symb(name)},#{args.size}#{args.map{|a| ",#{a}"}*""})"
  end
  def callrule(name,argc)
    margs=argc.times.map{|a| ",arg#{a}"}
    grammar=resolvegrammar(@grammar,name)
    if grammar
      @header<<"VALUE #{grammar}_#{name}(VALUE self #{",VALUE"*argc});"
      "#{grammar}_#{name}(self #{margs*""})"
    else
      rbcall(name,argc.times.map{|a| "arg#{a}"})
    end
  end
end
def gc_mark_var(v)
	"rb_global_variable(&#{v});"
end
$classlabels=Hash.new(0)
amethyst AmethystCTranslator < Amethyst {
  itrans = {[]}:ruby {[]}:c {[]}:init  ( char:ruby[]  | trans:{c<<it[0];init<<it[1];ruby<<it[2]} )* -> [c,init,ruby]
  
  rbtrans = Local[.* {rbbget(@self)}]
          | Args[rbtrans2]
          | Array[rbtrans2] 
          | Key[.:name rbtrans:args] -> (name=="self") ? "src" : "src.#{name}#{args!="" ? "(#{args})":""}"
          | Global[:name] -> "@#{name}"
          | Lambda[addlambda ] 
          | Result[ {"#{@name}.create( {#{@vars.size.times.map{|i| ":#{@varnames[i]}=>#{rbbget(@vars[i])}" }.sort*","} })"} ]
          | .

  rbtrans2 = rbtrans*:{it*""}

  rbcode = {"class #{@@grammar} < #{@@parent}\n"}:s
           {s<<@@defs*"\n";s<<"\n"}
           {@@callbacks.to_a.sort}=>[([:k :v]   {"def #{k}(bind)\n#{v}\nend\n"})*:x ]
           {s+=x*""}
           {s+="\nend"; s}
  
  trans =  Grammar[ {@@grammar=@name;@@parent=@parent} {@@lambdas=[] ;@@rcallbacks={};@@cbhash={}} {@@defs=[]} {@@defmethods=[]} {@@faillabel="fail"} {@@callbacks={}} {mktable(@rules)} {@@header=[]} {@@init=[]} @rules=>[trans*]:t rbcode:rbcode
            { "VALUE cls_#{@name};\n" }:s
            { s<<@@header.uniq.sort*"\n"+"\n"
							s<<"\n#include \"../lib/c/memo.c\"\n memo_struct *mem;VALUE memo_val;" if CurrentParser[:memoize]
							s<<"VALUE profile_report(VALUE self){printf(\"\\nhit: %i miss: %i hit: %i miss: %i\\n\",mem->hits[113],mem->miss[113],mem->hits[115],mem->miss[115]);return Qnil;}" if CurrentParser[:memoize]
							@@init<<"mem=memo_init(); memo_val=Data_Wrap_Struct(cls_AmethystParser,memo_mark,memo_free,mem); rb_global_variable(&memo_val); " if CurrentParser[:memoize]
							@@init<<"rb_define_method(cls_AmethystParser,\"profile_report\",profile_report,0);" if CurrentParser[:memoize]
              s<<t.sort*"\n"
              s<<@@lambdas*"\n"
              init="\n cls_#{@name}=rb_define_class(\"#{@name}\",rb_const_get(rb_cObject,rb_intern(\"#{@@parent}\"))); 
                    failobj=rb_eval_string(\"FAIL\");
                    #{@@init.uniq.sort*"\n"}
                    #{@@defmethods.sort*"\n" }
                   "
              [s,init,rbcode] } ]

         |  Rule[@name:name &{CurrentParser[:memoize]&&CurrentParser[:memoize].include?(name)} {@@rulename=name; Local.resetnumbering;resetlabels;@@locls={}} @body=>trans:body  
          { h="VALUE #{@@grammar}_#{name}(VALUE self #{map_index(@args){|i| ",VALUE a#{i}"}*""})" 
            @@header<<h+";"
            @@defmethods<< "rb_define_method(cls_#{@@grammar},\"#{@name}\",#{@@grammar}_#{@name},#{@args.size});"
						s=h+"{VALUE vals[#{@args.size}]; VALUE bind=bind_new2(#{@@locls.size}); #{map_index(@args){|i| bset(@args[i],"a#{i}")+";"}*""} int x;VALUE arg0,arg1,arg2,arg3;VALUE it; cstruct *ptr; Data_Get_Struct(self,cstruct,ptr);
int oldpos=ptr->pos;if (memo_pos(mem,#{@@memo_no=(@@memo_no||111)+2},ptr->src,ptr->pos)!=-1) {it=memo_value(mem,#{@@memo_no},ptr->src,ptr->pos);ptr->pos=memo_pos(mem,#{@@memo_no},ptr->src,ptr->pos);return it;} #{body}\n memo_add(mem,#{@@memo_no},ptr->src,oldpos,it,ptr->pos); return it;\nfail: memo_add(mem,#{@@memo_no},ptr->src,oldpos,failobj,ptr->pos); return failobj; }" } ]


       |  Rule[@name:name {@@rulename=name; Local.resetnumbering;resetlabels;@@locls={}} @body=>trans:body  
          { h="VALUE #{@@grammar}_#{name}(VALUE self #{map_index(@args){|i| ",VALUE a#{i}"}*""})" 
            @@header<<h+";"
            @@defmethods<< "rb_define_method(cls_#{@@grammar},\"#{@name}\",#{@@grammar}_#{@name},#{@args.size});"
            h+"{VALUE vals[#{@args.size}]; VALUE bind=bind_new2(#{@@locls.size}); #{map_index(@args){|i| bset(@args[i],"a#{i}")+";"}*""} int x;VALUE arg0,arg1,arg2,arg3;VALUE it; cstruct *ptr; Data_Get_Struct(self,cstruct,ptr);
            \n#{body}\nreturn it;\nfail: return failobj; }" } ]
        | Act[ .*:{addcallback(@pred ? ["(",it,") || FAIL"] : it)}:cbno {"it=#{rbcall(cbno,["bind"])}; #{@pred ? "FAILTEST(#{@@faillabel});" :"" }"} ]
        | CAct[.* {ar=*@ccode; 
                   @@header<<ar[0] if ar[0]
                   @@init<<ar[1] if ar[1]
                   "it=#{ar[2]};"}]

        | Apply[ ["_find"] {raise "TODO"} ]
				| Apply[ ["_test_size"] CAct[.:s] ] -> "if(ptr->pos+#{s}>=ptr->len) goto #{@@faillabel};"
        | Apply[ ["fails"] {"goto #{@@faillabel};"} ]
        | Apply[ ["eof"]   {"it=Qnil;if (ptr->pos<ptr->len) goto #{@@faillabel};"} ]
        | Apply[ ["empty"]   {"it=Qnil;"} ]
				| Apply[ ["advance_char"] {"it=rb_str_new(ptr->str+ptr->pos,1);ptr->pos++;"} ]
				| Apply[ ["advance_clas"] {"it=ame_curobj2(ptr)               ;ptr->pos++;"} ]

        | Apply[ ["_seq"] CAct[.:s] {"if (#{ary=s.split("");map_index(ary){|i| "ame_curstr2(ptr)[#{i}]==#{Lattice_Char.new.cchar(ary[i])}" }*"&&" })  ptr->pos+=#{s.size}; else goto #{@@faillabel};"}]
        | Apply[ .:name {0}:ii ( trans:aa {ii+=1} {"#{aa} arg#{ii-1}=it;"})*:args @self:app]
                 -> r=" #{args*""} it=#{callrule(name,ii)};"; cant_fail?(app) ? r : "#{r} FAILTEST(#{@@faillabel});"

        | Bind[trans:e {"#{e} #{bset(@name,"it")};\n" } ]
        | Seq[ trans*:t {t*""} ]
        | Or[ {label("accept")}:accept {label("oldpos")}:oldpos label("alt"):alt {1}:altno {@@cutlabel}:oldcutlabel {@@cuts}:oldcuts {@@cuts=nil;@@cutlabel=label("cut")}
           {"int #{oldpos}=ptr->pos;int #{@@cutlabel}=0;\n#{alt}_#{altno}:;"}:s
           ( &(.) {altno+=1}  rw("#{alt}_#{altno}",`trans`):t 
             {s+="#{t}\n;goto #{accept};\n"} 
             {s+="#{alt}_#{altno}: ptr->pos=#{oldpos};#{@@cuts ? (@@cuts=nil;"if (#{@@cutlabel}) goto #{@@faillabel};"): ""}"}  
           )*
           {@@cutlabel=oldcutlabel;@@cuts=oldcuts;s+"goto #{@@faillabel};\n #{accept}:;\n"}
          ]
        | Cut[]  {@@cuts=true;  @@cutlabel ? "#{@@cutlabel}=1;"  : ""}
        | Stop[] {@@stops=true; @@stoplabel? "#{@@stoplabel}=1;" : ""}
        | Memo[ .* {raise "TODO"}]
        | Many[ Apply[ ["anything"] ] ] -> "ptr->pos=ptr->len;"
        | Many[ {label("break")}:brk {label("oldpos")}:oldpos {label("accept")}:accept {@@stops}:oldstops {@@stoplabel}:oldstoplabel {@@stops=nil}  {@@stoplabel=label("stop")}
                rw(brk,`trans:t`)
                {s="int #{oldpos}; #{@@stops ? "int #{@@stoplabel}=0;":""} while(1){#{oldpos}=ptr->pos; #{t} #{@@stops ? "if (#{@@stoplabel}) goto #{accept}; } #{brk}: goto #{@@faillabel}; #{accept}:;" : "} #{brk}: ptr->pos=#{oldpos};"}   "
									@@stops=oldstops; @@stoplabel=oldstoplabel
									s
								}
              ]
        | Lookahead[ {label("accept")}:accept {label("reject")}:reject {label("oldpos")}:oldpos 
                     rw(reject,`trans:t`) 
                     {"int #{oldpos}=ptr->pos;\n #{t} x=1; goto #{accept};  #{reject}: x=0; #{accept}: it=Qnil; ptr->pos=#{oldpos}; if (x==0) goto #{@@faillabel};"} ]
        | Local[ .* { "it=#{bget(@self)};" } ]
        | Pass[ label("pass"):pass label("oldpass"):oldpass label("success"):success
                rw(pass,`@to=>trans:to`)
                { "cstruct #{oldpass}=*ptr; ptr->pos=ptr->len=0; ptr->ary=NULL;
                   #{@enter ?  "ptr->src=#{bget(@var)}; if(TYPE(ptr->src)==T_STRING) {ptr->str=RSTRING_PTR(ptr->src);ptr->len=RSTRING_LEN(ptr->src);} else { VALUE ary;    if (TYPE(ptr->src)==T_ARRAY) ary=ptr->src;    else  ary=rb_funcall(ptr->src,s_to_a,0);    ptr->ary=RARRAY_PTR(ary);    ptr->len=RARRAY_LEN(ary);}" : 
                    "ptr->src=failobj;ptr->ary=alloca(sizeof(VALUE));ptr->ary[0]=#{bget(@var)};ptr->len=1;"
                   }
                   #{to}
                   goto #{success};
                   #{pass}: *ptr=#{oldpass}; goto #{@@faillabel};
                   #{success}: *ptr=#{oldpass};
                " }
              ]
        | Switch_Char[ 
                     {"switch((unsigned char)*ame_curstr2(ptr)){"}:s
                     ( [.:c trans:t] {s+=c.cases() + " #{t} break;\n"})*
                     {s+"}"}
                     ]
        | Switch_Clas[ {"switchhash_#{@@grammar}_#{$classlabels[@@grammar]+=1}"}:sh {0}:ii {""}:init
                       {@@header<< "VALUE #{sh};"}
                       {"switch(FIX2LONG(rb_hash_aref(#{sh},rb_obj_class(ame_curobj2(ptr))))){"}:s
                       ( [.:c trans:t]{c.ary.each{|al| init+="next h[k]=#{ii} if k<=#{al}\\n";s+="case #{ii}/*#{al}*/:";ii+=1}}
                                      {s+="; #{t} break;\n"})*
                       {@@init  <<"#{sh}=rb_eval_string(\"Hash.new{|h,k|#{init}}\");#{gc_mark_var(sh)};"}
                       {s+"}"}
                     ]

  
  addlambda =  {"#{@@grammar}_#{@@rulename}_#{label("lambda")}"}:lambd  rw('fail',`trans:body`)
               { h="VALUE #{lambd}(VALUE self,VALUE bind)"
                 @@header<<h+";"
                 @@defmethods<<"rb_define_method(cls_#{@@grammar},\"#{lambd}\",#{lambd},1);"
                 @@lambdas<< h+"{VALUE vals[0]; /*todo unify with rule and get args*/ cstruct *ptr; int x;VALUE it;VALUE arg0,arg1,arg2,arg3;\n#{body}\nreturn it;\nfail: return failobj; }" }
               {"AmethystLambda.new(:#{lambd},self,bind)" }


  rw(word,prc) = {@@faillabel}:rwo {@@faillabel=word } apply(prc):x {@@faillabel=rwo; x }
  
  addcallback(s) = {s}=>rbtrans2:s {addcallback2(s)} 
}
