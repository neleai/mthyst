
class AmethystCTranslator < Amethyst 
	def addcallback2(cb)
		@cbno||=0
		@cbno+=1
		n=Local["#{@rulename}_#{@grammar}cb",@cbno].desc
		@callbacks[n]=cb
		n
	end
	def desc(s)
		return @locls[s.desc] if @locls[s.desc]
		@locls[s.desc]=@locls.size
	end
	def bget(s)
		s=desc(s)
		return "rb_ary_entry(bind,#{s})"
		"BGET(#{s})"
	end
	def bset(s,e)
		s=desc(s)
		return "rb_ary_store(bind,#{s},#{e})"
		"BSET(#{s},#{e})"
	end
	def rbbget(s)
		"bind[#{desc(s)}]"
	end
	def iget(s)
		"rb_ivar_get(self,rb_intern(\"@#{s}\"))"
		"IGET(#{s})"
	end
	def iset(s,e)
		"rb_ivar_set(self,rb_intern(\"@#{s}\"),#{e})"
		"ISET(#{s},#{e})"
	end
	def resetlabels
		@labels=Hash.new(0)
	end
	def label(s)
		@labels[s]+=1
		"#{s}#{@labels[s]}"
	end
	def mktable(r)
		@ruletable={}
		r.each{|e| @ruletable[e.name]=e}
	end
	def callrule(name,argc)
		margs=argc.times.map{|a| ",arg#{a}"}
		grammar=resolvegrammar(@grammar,name)
		if grammar
			"#{grammar}_#{name}(self #{margs})"
		else
			"CALL(#{name},#{argc} #{margs})"
		end
	end
end

amethyst AmethystCTranslator < Amethyst {
	itrans = {[]}:ruby {[]}:c {[]}:init  ( char:ruby[]  | trans:{c<<it[0];init<<it[1];ruby<<it[2]} )* -> [c,init,ruby]
	
	transfn = trans:t -> "proc{#{t}}"
	rbtrans = Local[.* {rbbget(@self)}]
					| Args[rbtrans*:a] -> a*""
					| Array[rbtrans*:a] -> a*""
		      | Strin[rbtrans*:a] -> a*""
		      | Key[.:name] -> (name=="self") ? "@src" : "@src.#{name}"
      		| Global[:name] -> "@#{name}"
    		  | Exp[addlambda ] 
		      | .


	rbcode = {"class #{@@grammar} < #{@@parent}\n"}:s

	{s<<@@defs*"\n";s<<"\n"}
	{@@callbacks.to_a.sort}=>[([:k :v]   {"def #{k}(bind)\n#{v}\nend\n"})*:x ]
	{s+=x*""}
	{s+="\nend"; s}
	
	trans =  Grammar[ {@@grammar=@name;@@parent=@parent} {@@lambdas=[]} {@@defs=[]} {@@defmethods=[]} {@@faillabel="fail"} {@@callbacks={}} {mktable(@rules)} {@@header=[]} @rules=>[trans*]:t rbcode:rbcode
				    { "VALUE cls_#{@name};\n" }:s
						{	s<<@@header.sort*"\n"+"\n"
							s<<t.sort*"\n"
							s<<@@lambdas*"\n"
        		  init="\n cls_#{@name}=rb_define_class(\"#{@name}\",rb_const_get(rb_cObject,rb_intern(\"#{@@parent}\"))); 
failobj=rb_eval_string(\"FAIL\");
#{@@defmethods.sort*"\n" }
"
							[s,init,rbcode] } ]
				|  Rule[@name:name {@@rulename=name; Local.resetnumbering;resetlabels;@@locls={}} @body=>trans:body  
          { h="VALUE #{@@grammar}_#{name}(VALUE self #{map_index(@args){|i| ",VALUE a#{i}"}})" 
						@@header<<h+";"
						@@defmethods<< "rb_define_method(cls_#{@@grammar},\"#{@name}\",#{@@grammar}_#{@name},#{@args.size});"
						h+"{VALUE vals[#{@args.size}]; VALUE bind=rb_ary_new2(#{@@locls.size}); #{map_index(@args){|i| bset(@args[i],"a#{i}")+";"}} int x;VALUE arg0,arg1,arg2,arg3;VALUE it;
\n#{body}\nreturn it;\nfail: return failobj; }" } ]
				| Act[ .*:{addcallback(@pred ? ["(",it,") || FAIL"] : it)}:cbno {"it=CALL(#{cbno},1,bind); #{@pred ? "FAILTEST(#{@@faillabel});" :"" }"} ]
				| CAct[.*:c] ->"it=#{c};"
				| Apply[ .=>["super"] {rule=@@ruletable[@@rulename];  failwrap(map_index(rule.args){|i|"vals[#{i}]=#{bget(rule.args[i])};"}*""+ "it=rb_call_super(#{rule.args.size},vals);")} ]
				| Apply[:name {0}:ii ( trans:aa {ii+=1} {"#{aa} arg#{ii-1}=it;"})*:args 
            failwrap(" #{args} it=#{callrule(name,ii)};")]
				| Seq[ trans*:t {t*""} ]
				| Bind[ @expr=>trans:e {"#{e}\n #{bset(@name,"it")}; " } ]
				| Or[ {label("accept")}:accept {@@faillabel}:fail {label("oldpos")}:oldpos label("alt"):alt {0}:altno
					 ( &(.) {altno+=1} rw("#{alt}_#{altno+1}",`trans`))*:t
					 {s="int #{oldpos}=ame_getpos(self);\n"}
           {s+=map_index(t){|i| "#{alt}_#{i+1}: ame_setpos(self,#{oldpos});if (#{iget("cut")}!=Qnil) {#{iset("cut","Qnil")}; goto #{fail};}\n #{t[i]} \n#{iset("cut","Qnil")};goto #{accept};\n"}*""}
           {"#{s}  #{alt}_#{altno+1}:  ame_setpos(self,#{oldpos}); goto #{fail};\n #{accept}:;\n"}
					]
				| Cut[] {"#{iset("cut","Qtrue")};"}
				| Stop[] {"#{iset("stop","Qtrue")};"}

				| Many[ {label("break")}:brk {label("oldpos")}:oldpos
						rw(brk,`trans:t`)
						{"int #{oldpos}; while(1){#{oldpos}=ame_getpos(self); #{t} if (#{iget("stop")}!=Qnil){{#{oldpos}=ame_getpos(self);goto #{brk};} } } #{brk}: #{iset("stop","Qnil")};  ame_setpos(self,#{oldpos}); "}
					]
				| Lookahead[ {label("accept")}:accept {label("reject")}:reject {label("oldpos")}:oldpos 
										 rw(reject,`trans:t`) 
										 {"int #{oldpos}=ame_getpos(self);\n #{t} x=1; goto #{accept};  #{reject}: x=0; #{accept}: it=Qnil; ame_setpos(self,#{oldpos}); if (x==#{@neg ? 1 : 0}) goto #{@@faillabel};"} ]
				| Local[ .* { "it=#{bget(@self)};" } ]
				| Result[ { s="#{@name}.create( {#{@vars.map{|l| ":#{l[0]}=>#{rbbget(l)}" }.sort*","} })"
					cbno=addcallback(s)
					"it=CALL(#{cbno},1,bind);"
				} ]
				| Pass[ label("pass"):pass label("oldpos"):oldpos label("oldlen"):oldlen label("oldsrc"):oldsrc label("success"):success label("fail"):fail
						rw(pass,`@to=>trans:to`)
					{  "int #{oldpos}=ame_getpos(self); int #{oldlen}=ame_getlen(self); VALUE #{oldsrc}=ame_getsrc(self); int #{fail}=0;
ame_setsrc(self,#{bget(@var)}); ame_setpos(self,0); ame_setlen(self,FIX2INT(rb_funcall(ame_getsrc(self),rb_intern(\"size\"),0)));
 #{to}
	goto #{success};
	#{pass}: #{fail}=1;
	#{success}: ame_setsrc(self,#{oldsrc}); ame_setpos(self,#{oldpos}); ame_setlen(self,#{oldlen});
	if(#{fail}) goto #{@@faillabel};
" }
					]
				| Switch[ label("chr"):chr 
									{@@defs<<@defs if @defs}
									{"char #{chr}=#{@act};  switch(#{chr}){"}:s
										( [.:c trans:t] {s+=c.map{|n| n=="default" ? "default:;" : "case #{n}:;"}*"" + " #{t} break;"})*
									{s+"}"}
								]

	
	addlambda =  {"#{@@grammar}_#{@@rulename}_#{label("lambda")}"}:lambd  rw('fail',`trans:body`)
							  { h="VALUE #{lambd}(VALUE self,VALUE bind)"
            @@header<<h+";"
						@@defmethods<<"rb_define_method(cls_#{@@grammar},\"#{lambd}\",#{lambd},1);"
            @@lambdas<< h+"{VALUE vals[0]; /*todo unify with rule and get args*/  int x;VALUE it;VALUE arg0,arg1,arg2,arg3;\n#{body}\nreturn it;\nfail: return failobj; }" }
							 {"AmethystLambda.new(:#{lambd},self,bind)" }

	failwrap(s) = {"#{s} FAILTEST(#{@@faillabel});" }

	rw(word,prc) = {@@faillabel}:rwo {@@faillabel=word } apply(prc):x {@@faillabel=rwo; x }
	
	addcallback(s) = {s}=>rbtrans:s {addcallback2(s)} 
}
