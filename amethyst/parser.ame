def connectstring(ary)
	r=[]
	s=nil
	ary.each{|a|
		if a.is_a? String
			s||=""
			s+=a
		else
			r<<s if s
			s=nil
			r<<a
		end
	}
	r<<s if s
	r
end

#@Or and @Seq are necessary for collect

amethyst AmethystParser < Amethyst{
	igrammar = ((~'amethyst'   . )+:{it.join} | grammar)*:a -> a

	grammar = "amethyst" "" name:name ("<" "" name:parent |empty {parent="Amethyst"} ) 
"{" rule*:rules "}"  @Grammar
	
  rule = {@@locals=[];$appends=[];@@bnding=Bnding[]} {@@bnding}:bnding  
				 "" name:name  ruleargs:args "=" expression:body  
	   		 {_body(body)}:body {@@locals.uniq}:locals {body=Seq[{:ary=>($appends.uniq.map{|a| _Bind(a,Act["[]"])}+[body])}]; }	 @Rule

	expression = choice
	
	choice = listOf('sequence',`"|"`):ary @Or
	
	sequence =  (nr prefixed)*:ary  @Seq

  prefixed   = ("&" | "~"):neg host_expr:expr->   Pred[expr[0],neg=="~"]
             | ("&" | "~"):neg prefixed:m    -> Lookahead[m,neg=="~"]
						 | "" postfixed

	postfixed =  term:from 
										(~_     (	 '=>'     term:{Pass[from,it]} 
												     | '['      expression:{from=Enter[from,it]} "]" -> from
		 												 | <+*>:one -> Many[from,one=="+"]
    		                     | '?'      -> Or[from,Apply["empty"]]
													 	 | ':' (  (key | name):name ('[]'?):append -> _Bind(name,from,append=='[]')
            		   					        | host_expr:e                      -> Seq[ _Bind("it",from) , Act[e] ]
																   )
										):from  )* {from}

	until(e) = ( seq(e) break 
             | _args('#'+'{','}'):x[]
             | ('\\':x[])? .:x[]
             )* -> x

	term  = 'nested(' expression:expr ")" -> Nested[expr]
				| 'break' -> Seq[Cut[],Stop[]]
		 	  | call
				| &<.:> '.'? -> Apply["anything"]
				| '[' expression:e "]" -> Enter[Apply["anything"],e]
 			  | key:{Act[it]}
			  | host_expr | line_host_expr
				| '"'  until('"' ):s -> Apply["token" ,quote(s)]
		 	  | '\'' until('\''):s -> Apply["seq"   ,quote(s)]
      	| '<'  until('>' ):s -> Apply["regch","/["+s.join+"]/"]
				| (number ('...'|'..') number | number):num -> Apply["member",num.join]
		    | '(' expression:x ")" ( '[]'	collect(x) | empty {x} )
				| '#' (~endline .)*:c -> Comment[c]

  collect(ors) = -> a=autovar; Seq[Or[{:ary=>ors.ary.map{|ands| Seq[{:ary=>ands.ary.map{|expr| Append[a,expr]}}]}}],a]
	
	call = className:klas '::' name:name argsOpt:arg -> Apply[[klas,name],arg]
			 | className:klas                            -> Apply["clas",klas]
			 |                     name:name argsOpt:arg -> Apply[name,arg]
 
	key         = '@' className:name             -> Result[{:name=>name,:vars=>Object.const_get(name).instance_variable_get(:@attrs)}]
              | '@'      name:name argsOpt:arg -> Key[name,arg]
							| '@@'     name:name             -> Global[name]


	eChar = '\\' char:c   -> "\\#{c}"
  	  	| _args('#'+'{','}')
				| char
	

	ruleargs = (argsOpt)=>[ Args[ :name {_Local(name) }:result[] ]* ] ->  result || []
	
	nr = ~("" name argsOpt "=")
	
	argsOpt = ~_ args('(',')') 
          | {[]}

	args(o,c) = __args(o,c):r { r+[',']}=>[procargs]
						
	_args(o,c) = __args(o,c):r -> Args[{:ary=>([o]+r+[c])}]

	__args(o,c) = seq(o) "" rubyarg*:r seq(c) -> r
		
	rubyarg  = '`' expression:e '`' -> Lambda[_body(e)]
           | _args('(',')')	| _args('[',']') | _args('{','}')
					 | '"'  until('"' ):s  -> Strin[connectstring(['"']+s+['"'])]
					 | '\'' until("'" ):s  -> Strin[connectstring(["'"]+s+["'"])]
					 | ('...' | '..')
					 | ( ":@":n[] | <$.:>:n[] | empty) ~_ name:n[] -> n.join
					 | key
					 | <^`'"(){}\[\]>

	procargs = {@@ary=[];@@tmp=[]}
						 ( .:c &{c==','} {@@ary<<Args[{:ary=>@@tmp}];@@tmp=[]}
							 | procargs2
						 )*
						 {@@ary}
	
	procargs2 =	Args[ procargs2* ]
						| .:a {@@tmp<<a}

	name           =  (<_a-zA-Z> <_a-zA-Z0-9>*)[]:{it.join}
  className      =  (    <A-Z> <_a-zA-Z0-9>*)[]:{it.join}
	
	host_expr = __args('{','}'):r {Act[Args[{:ary=>r}]]}
	line_host_expr =  '->' (endline break | .)*:s   {"{"+s.join+"}"}=>[ host_expr ]
}
