makeclasses(Object,
    [:Args,:o,:c,:r],
    [:Key,:name,:expr,:args],
    [:Resul,:name,:expr,:args,:vars],
    [:Enter,:name,:cls,:expr],
    :Apply,
    :Nested,
    :Exp,
    :ExpKey,
    :Foreign,
    [:Append,:name,:expr],
    [:Set,:name,:expr],
    [:Many,:o],
    :Many1,
    :Comment,
    [:Act,:uses],
    [:Pred,:uses],
    :Lookahead,
    :Not,
    :Seq,
    :Or,
    :And,
		[:Strin],
		[:Variable,:number],
		[:Pass,:var,:to],
    [:Enter,:klas],
    [:Rule,:name,:args,:locals,:body],
    [:Grammar,:name,:parent,:rules]
)

def quote(s)
  s=s*""
  '"'+s.gsub('\\"','"').gsub('"','\\"')+'"'
end

$av=0
class Autovar
	def to_s
		return "avar"+@no.to_s if @no
		$av+=1
		@no=$av
		to_s
	end
end
def autovar
	Autovar.new
end

amethyst AmethystParser < Amethyst{
	igrammar = (~'amethyst' . | grammar)*:a -> a

	grammar = "amethyst" name:name ("<" name:parent |empty {parent="Amethyst"} ) 
"{" rule*:rules "}"  @Grammar
	
	rule = name:name ruleargs:args "=" expression:body {$av=0} @Rule

	expression = choice
	
	choice = listOf('sequence',`"|"`):ary @Or
	
	sequence =  (nr prefixed)*:ary  @And

  prefixed   = "~" modifier:m -> Not[m]
             | "&" inlineHostExpr:expr  -> Pred[expr]
             | "&" ~inlineHostExpr:expr  modifier:m -> Lookahead[m]
             | modifier:from "=>" modifier:to ->And[Set[{:name=>"it",:expr=>from}] ,Pass[{:to=>to, :var=>Variable["it"]}]]
						 | modifier

 		modifier = term:t optIter(t):t  (~space binding(t) | empty {t})
             | binding(Apply["anything"])
             | "#" (~endline .)*:c -> Comment[c]
 
	 optIter(t) = "*"  -> a=autovar; And[Set[{:name=>a, :expr=> Act["[]"]}], Many[{:ary=>[Append[{:name=>a,:expr=>t}]],:o=>autovar}],Act[a]]
              | "+"   -> a=autovar; And[Set[{:name=>a, :expr=> Act["[]"]}], Append[{:name=>a,:expr=>t}], Many[{:ary=>[Append[{:name=>a,:expr=>t}]],:o=>autovar}],Act[a]]
              | "?"   -> Or[t,Apply["empty"]]
              | empty -> t
  
	binding(exp) = {exp}:expr ":" name:name ('[]' @Append | empty @Set )
                 | ":" inlineHostExpr:e -> And[ Set[{:name=>"it", :expr=>exp}] , Act[e] ]


	term  = (className | "" {"Object"}):cls '[' expression:expr "]" -> And[Apply["clas",cls], Enter[expr]]
				| className:cls -> Apply["is_a",cls]
				| "nested" '(' expression:expr ")" -> Nested[expr]
		 	  | application
 			  | key
			  | ("->" atomicHostExpr | "" inlineHostExpr):x    ->  Act[x]
				| "\"" (~'"' eChar)*:s '"' -> Apply["token" ,quote(s)]
		 	  | "'"  (~'\''  eChar)*:s '\''  -> Apply["seq",quote(s)]
 			  | number:{Apply["exactly",it]}
      	| "<" (~">" eChar)+:x  ">"                            ->  Apply["regch","/[#{x}]/"]
		    | "(" expression:x ")[]"															collect(x)
				| "(" expression:x ")"                                ->  x

	application = name:klas '::' name:rule argsOpt('(',')'):arg @Foreign
  	      		| name:rule argsOpt('(',')'):arg -> Apply[rule,arg]

	key         = "@" className:name  argsOpt('[',']'):args  @Resul
              | "@" name:name   @Key

	collect(ors) = -> a=autovar; And[Or[{:ary=>ors.ary.map{|ands| And[{:ary=>ands.ary.map{|expr| Append[{:name=>a,:expr=>expr}]}}]}}],Act[a]]

	eChar = '\\' char:c   -> "\\#{c}"
  	  	| _args('#{','}')
				| char

	ruleargs = argsOpt('(',')')
	
	nr = ~(name ruleargs "=")
	
	argsOpt(o,c) = args(o,c) 
                | empty -> []

	args(o,c) = __args(o,c):r {
							r<< ','
							ary=[]
							tmp=[]
							r.each{|a|
								if a==','
									ary<<Args[{:ary=>tmp}];tmp=[]
								else
									tmp<<a
								end
							}
							ary
						}

	_args(o,c) = __args(o,c):r -> Args[{:ary=>([o]+r+[c])}]

	__args(o,c) = seq(o) "" rubyarg*:r seq(c) -> r
		
	rubyarg  = '`' expression:e '`' -> Exp[e]
           | _args('(',')')
					 | _args('[',']')
					 | _args('{','}')
					 | '"' (~'"'   eChar)*:s '"'  -> Strin[['"']+ s+['"']]
					 | '\''(~'\''  eChar)*:s '\'' -> Strin[['\'']+s+['\'']]
					 | ('@@' {"@"}:n[] | <.:>:n[] | empty) <a-zA-Z_>+:n[] -> n*""
					 | key:k -> ExpKey[k] 
					 | <^`{}()'"\[\]>

	nameFirst      = <_$.^> | letter

  nameRest       = nameFirst | digit

  className      = _* (upper nameRest* )[]:{leterize(it*"")}
	
	name = _* (nameFirst nameRest*)[]:{leterize(it*"")}

	inlineHostExpr = args('{','}')

	number = <0-9>+

	atomicHostExpr = (~endline .)*:s   {"{#{s*""}}"}=>[ inlineHostExpr ]
}
