require 'ast'

def connectstring(ary)
	r=[]
	s=nil
	ary.each{|a|
		if a.is_a? String
			s||=""
			s+=a
		else
			r<<s if s
			s=nil
			r<<a
		end
	}
	r<<s if s
	r
end

amethyst AmethystParser < Amethyst{
	igrammar = ((~'amethyst'   . )+:{it*""} | grammar)*:a -> a

	grammar = "amethyst" name:name ("<" name:parent |empty {parent="Amethyst"} ) 
"{" rule*:rules "}"  @Grammar
	
  rule = {@@locals=[];@@bnding=Bnding[]} {@@bnding}:bnding  
				 name:name  ruleargs:args "=" expression:body  
	   		 {_body(body)}:body {@@locals.uniq}:locals	 @Rule

	expression = choice
	
	choice = listOf('sequence',`"|"`):ary @Or
	
	sequence =  (nr prefixed)*:ary  @Seq

  prefixed   = "&" inlineHostExpr:expr  -> Pred[expr]
             | ("&" | "~"):neg  prefixed:m -> Lookahead[m,neg=="~"]
						 | (modifier | "" &<.:\[> "."? {Apply["anything"]}):from 
										(~_     (	 "=>" prefixed:{from=Pass[from,it]} 
												     | "[" expression:{from=Enter[from,it]} "]" 
		 												 | ("*"| "+"):one  { Many[from,one=="+"]}:from
    		                     | "?"  {Or[from,Apply["empty"]]}:from
													 	 | ":" (  (key | name):name ('[]' {true} | empty {nil} ):append {_Set(name,from,append)}:from
            		   					        | inlineHostExpr:e  {Seq[ _Set("it",from) , Act[e] ]}:from
																   )	
										)				)* {from}

 		modifier = term
             | "#" (~endline .)*:c -> Comment[c]

	term  =  className:cls -> Apply["clas",cls]
				| "nested" '(' expression:expr ")" -> Nested[expr]
				| "break" -> Seq[Cut[],Stop[]]
		 	  | application
 			  | key
			  | ("->" atomicHostExpr | "" inlineHostExpr):x    ->  Act[x]
				| "\"" ('"'  break| eChar:s[])*  -> Apply["token" ,quote(s)]
		 	  | "'"  ('\'' break|  eChar:s[])* -> Apply["seq"   ,quote(s)]
 			  | number:{Apply["exactly",it]}
      	| "<" (">" break | eChar:x[])*                            ->  Apply["regch","/[#{x}]/"]
		    | "(" expression:x ")" ( '[]'	collect(x) | empty {x} )

	application = (name:klas '::' name:rule {[klas,rule]} | name):rule argsOpt('(',')'):arg -> Apply[rule,arg]

	key         = "@" className:name  argsOpt('[',']'):args {Object.const_get(name).instance_variable_get(:@attrs)}:vars @Result
              | "@" name:name  -> Act[Args[Key[{:name=>name}]]]
							| "@@" name:name -> Act[Args[Global[name]]]

  collect(ors) = -> a=autovar; Seq[Or[{:ary=>ors.ary.map{|ands| Seq[{:ary=>ands.ary.map{|expr| Append[a,expr]}}]}}],Act[a]]

	eChar = '\\' char:c   -> "\\#{c}"
  	  	| _args('#{','}')
				| char

	ruleargs = (argsOpt('(',')'))=>[addargs]

	addargs= Args[ :name {_Local(name) }:result[] ]* -> result || []

	
	nr = ~(name argsOpt('(',')') "=")
	
	argsOpt(o,c) = args(o,c) 
                | empty -> []

	args(o,c) = __args(o,c):r { r+[',']}=>[procargs]
						

	_args(o,c) = __args(o,c):r -> Args[{:ary=>([o]+r+[c])}]

	__args(o,c) = seq(o) "" rubyarg*:r seq(c) -> r
		
	rubyarg  = '`' expression:e '`' -> Exp[_body(e)]
           | _args('(',')')					 | _args('[',']')					 | _args('{','}')
					 | '"':s[]  ('"'  break |  eChar)*:s[]  -> Strin[connectstring(s)]
					 | '\'':s[] ('\'' break |  eChar)*:s[]  -> Strin[connectstring(s)]
					 | ( ":@":n | <$.:>:n | empty) ~_ name:n[] -> n
					 | ~_ key
					 | <^`{}()'"\[\]>

	procargs = {@@ary=[];@@tmp=[]}
						 ( .:c &{c==','} {@@ary<<Args[{:ary=>@@tmp}];@@tmp=[]}
							 | procargs2
						 )*
						 {@@ary}
	
	procargs2 =	Args[ procargs2* ]
						| .:a {@@tmp<<a}

	nameFirst      = letter | '_'

  nameRest       = nameFirst | digit

  className      = "" (upper nameRest* )[]:{leterize(it*"")}
	
	name = "" (nameFirst nameRest*)[]:{leterize(it*"")}

	inlineHostExpr = args('{','}')

	number = <0-9>+

	atomicHostExpr = (~endline .)*:s   {"{#{s*""}}"}=>[ inlineHostExpr ]
}
