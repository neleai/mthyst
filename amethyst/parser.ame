#@Or_AST and @Seq_AST are necessary for collect
$agram=0
class AmethystParser < Amethyst
  memoize "name","argsOpt"
  #use_implicit_variables
end
amethyst AmethystParser {
  file     = (  grammar
             | {pos}:oldpos {@@locals=[];@@appends=[];@@bnding=Bnding[]}  lambda {x="amethyst Anon#{$agram+=1} { expr=#{src[(oldpos+2)..(pos-3)]}\ninit=.:@@bind }";puts x.inspect;x}=>[ grammar:g ] 
                {g.rules[0].body=Seq_AST[Act[g.rules[0].locals.map{|el| [el,"=eval(\"#{el[0]}=#{el[0]}\",@bind);"] }],g.rules[0].body,Act[g.rules[0].locals.map{|el| ["$passit=",el,";eval(\"#{el[0]}=$passit\",@bind);"] }]]}
                                                 -> ["(",g,";ame_lambda(#{g.name},binding))"]
             | (~'amethyst' ~'(|'   . )
             )*

  grammar = 'amethyst' '_module'?:module "" name:name ("<" "" name  |{"Amethyst"}):parent
"{" (rule|rule2)*:rules "}"  @Grammar
 
  rule = {@@locals=[];@@appends=[];@@bnding=Bnding[]} {@@bnding}:bnding  
         "" name:name  ruleargs:args "=" expression:body  
          {Bind[local("_result"),body]}:body {@@locals.uniq}:locals {body=Seq_AST[{:ary=>(@@appends.uniq.map{|a| Bind[a,Act["[]"]]}+[body])}]; }   @Rule

  rule2 = {@@locals=[];@@appends=[];@@bnding=Bnding[]} {@@bnding}:bnding 
         "" name:name
         "["
            ( 
                    ","? "" (name):k ( ':' expression:e -> Pass[Apply["anything"],e]
                               | '=' rubyarg:r    -> Or[Apply["anything"],Act[Args[r]]] 
                               | -> Apply["anything"]
                               ):{Bind[local(k),it]}
              
            )*:arg
         "]" "=" expression:body
          {[local("_args")]}:args
          {Bind[local("_result"),body]}:body {@@locals.uniq}:locals {body=Seq_AST[{:ary=>([Enter[Act[local("_args")],arg]]+@@appends.uniq.map{|a| Bind[a,Act["[]"]]}+[body])}]; }   @Rule
  
  expression = listOf(`sequence`,`"|" ~')'`):ary @Or_AST  
  sequence =  (nr ","? "" prefixed)*:ary  @Seq_AST
  nr = ~("" name argsOpt "=")

  prefixed   = <&~>:neg inline_host_expr:expr-> Pred[expr[0],neg=="~"]
             | <&~>:neg prefixed:m    -> Lookahead[m,neg=="~"]
             | postfixed

  postfixed =  term:from 
                    (~_     (  '=>'     term:e           -> Pass_AST[from,e] 
                            | '['      expression:e "]" -> Enter_AST[from,e]
                            | <+*>:one -> Many[from,one=="+"]
                            | '?'      -> Or_AST[from,Apply["empty"]]
                            | ':' '['(name | rubyarg*):name ']' {name=local(name)} ->  @@appends<< name if name.is_a?(Local); Append_AST[name,from]
                            | ':' (  (key | name):name ('[]'?):append -> @@appends<< local(name) if append && local(name).is_a?(Local); append=='[]' ? Append_AST[name,from] : Bind[local(name),from]
                                  | inline_host_expr:e                      -> Seq_AST[ Bind[local("it"),from] , Act[e] ]
                                  )
                    ):from  )* {from}

  
  cases = className:clas  ~'::'                      -> Apply["clas",clas]
        | ((number ('...'|'..') number)[]:{it.join} | number):num -> Apply["member",num.to_s]
        | string_like('<','>'):s -> Apply["regch","/["+s+"]/"]

  term  = 'break' -> Seq_AST[Cut[],Stop[]]
        | cases
        | call
        | &<.:> '.'? -> Apply["anything"]
        | '[' expression:e "]" -> Enter_AST[Apply["anything"],e]
        | key:{Act[it]}
        | host_expr
        | string_like('"','"'):s -> Apply["token" ,quote(s)]
        | string_like("'","'"):s -> Apply["seq"   ,quote(s)]
        | '#'  line:s        -> Comment[s]
        | '(' expression:x ")" ( '[]'  collect(x) | {Parenthesis[x]} )

  collect(ors) = -> a=autovar; Seq_AST[Or_AST[{:ary=>ors.ary.map{|ands| Seq_AST[{:ary=>[Bind[a,Act["[]"]]]+ands.ary.map{|expr| Append_AST[a,expr]}}]}}],a]
  
  call = className:klas '::' name:name argsOpt:arg ("" lambda:[arg])? -> Apply[[klas,name],arg]
       |                     name:name argsOpt:arg ("" lambda:[arg])? -> Apply[name,arg]
 
  key         = '@' className:name             -> Result[{:name=>name}]
              | '@'      name:name argsOpt:arg -> Key[name,arg]
              | '@@'     name:name             -> Global[name]
              | '@>'     name:name             -> Contextual_Argument[name]
              | '@<'     name:name             -> Contextual_Return[name]

  name           =  (<_a-zA-Z> <_a-zA-Z0-9>*)[]:{it.join}
  className      =  (    <A-Z> <_a-zA-Z0-9>*)[]:{it.join}

  ruleargs = (argsOpt)=>[ Args[ :name {local(name) }]* ]
  
  
  argsOpt = ~_  _args('(',')'):r { r+[',']}=>[procargs] 
          | {[]}

  procargs = {@@ary=[];@@tmp=[]}
             ( .:c &{c==','} {@@ary<<Args[{:ary=>@@tmp}];@@tmp=[]}
               | procargs2
             )*
             {@@ary}
  
  procargs2 =  Args[ procargs2* ]
            | .:a {@@tmp<<a}


  args(o,c) = _args(o,c):r -> Args[{:ary=>([o]+r+[c])}]

  _args(o,c) = seq(o) "" rubyarg*:r seq(c) -> r
  
  lambda   = '`' expression:e "`" -> Lambda[Bind[local("_result"),e]]
           | '(|' expression:e "|)" -> Lambda[Bind[local("_result"),e]]

  
  rubyarg  = lambda
           | args('(',')')  | args('[',']') | args('{','}')
           | '"' interpolated("\""):s      -> Strin[['"']+s+['"']]
           | <a-z0-9_>:e '<<' -> [e,'<<']
           | string_like("'","'"):s  -> Strin[["'"+s+"'"]]
           | ('...' | '..')
           | ( ":@":[n] | <$.:>:[n] )? ~_ name:[n] -> n.join
           | key
           | <^`'"(){}\[\]>

  
  interpolated(e) =  ( seq(e) break 
             | args('#{','}'):[x]
             | ('\\':[x])? .:[x]
             )* -> x

  
  inline_host_expr = _args('{','}'):r {Act[Args[{:ary=>r}]]}
  host_expr = inline_host_expr 
            | '->' line:s   {"{"+s+"}"}=>[ inline_host_expr ]  

  string_like(start,end) = seq(start) until(end)
}

class AmethystParser < Amethyst
	def local(x)
    return Args[*x] if x.is_a?(Array)
		x.is_a?(String) ? (l=Local[x,@bnding];@locals<<l;l) : x
	end
end
