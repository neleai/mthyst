def connectstring(ary)
	r=[]
	s=nil
	ary.each{|a|
		if a.is_a? String
			s||=""
			s+=a
		else
			r<<s if s
			s=nil
			r<<a
		end
	}
	r<<s if s
	r
end

#@Or and @Seq are necessary for collect

amethyst AmethystParser < Amethyst{
	igrammar = ( (~'amethyst'   . )+:{it.join}
             | grammar
						 | "`" expression '`'
             )*

	grammar = "amethyst" "" name:name ("<" "" name  |{"Amethyst"}):parent
"{" rule*:rules "}"  @Grammar
	
  rule = {@@locals=[];$appends=[];@@bnding=Bnding[]} {@@bnding}:bnding  
				 "" name:name  ruleargs:args "=" expression:body  
	   		 {_body(body)}:body {@@locals.uniq}:locals {body=Seq[{:ary=>($appends.uniq.map{|a| _Bind(a,Act["[]"])}+[body])}]; }	 @Rule

	
	expression = listOf('sequence',`"|"`):ary @Or	
	sequence =  (nr "" prefixed)*:ary  @Seq
	nr = ~("" name argsOpt "=")

  prefixed   = <&~>:neg inline_host_expr:expr-> Pred[expr[0],neg=="~"]
             | <&~>:neg prefixed:m    -> Lookahead[m,neg=="~"]
						 | postfixed

	postfixed =  term:from 
										(~_     (	 '=>'     term:{Pass[from,it]} 
												     | '['      expression:{from=Enter[from,it]} "]" -> from
		 												 | <+*>:one -> Many[from,one=="+"]
    		                     | '?'      -> Or[from,Apply["empty"]]
													 	 | ':' (  (key | name):name ('[]'?):append -> _Bind(name,from,append=='[]')
            		   					        | inline_host_expr:e                      -> Seq[ _Bind("it",from) , Act[e] ]
																   )
										):from  )* {from}

	
	cases =  className:klas  ~'::'                       -> Apply["clas",klas]
				| (number ('...'|'..') number | number):num -> Apply["member",num.join]
      	| '<'  until('>' ):s -> Apply["regch","/["+s.join+"]/"]

	term  = 'nested(' expression:expr ")" -> Nested[expr]
				| 'break' -> Seq[Cut[],Stop[]]
				| cases
		 	  | call
				| &<.:> '.'? -> Apply["anything"]
				| '[' expression:e "]" -> Enter[Apply["anything"],e]
 			  | key:{Act[it]}
			  | host_expr
				| '"'  until('"' ):s -> Apply["token" ,quote(s)]
		 	  | '\'' until('\''):s -> Apply["seq"   ,quote(s)]
				| '#'  until('\n'):s -> Comment[s]
		    | '(' expression:x ")" ( '[]'	collect(x) | empty {x} )

  collect(ors) = -> a=autovar; Seq[Or[{:ary=>ors.ary.map{|ands| Seq[{:ary=>ands.ary.map{|expr| Append[a,expr]}}]}}],a]
	
	call = className:klas '::' name:name argsOpt:arg -> Apply[[klas,name],arg]
			 |                     name:name argsOpt:arg -> Apply[name,arg]
 
	key         = '@' className:name             -> Result[{:name=>name,:vars=>Object.const_get(name).instance_variable_get(:@attrs)}]
              | '@'      name:name argsOpt:arg -> Key[name,arg]
							| '@@'     name:name             -> Global[name]

	name           =  (<_a-zA-Z> <_a-zA-Z0-9>*)[]:{it.join}
  className      =  (    <A-Z> <_a-zA-Z0-9>*)[]:{it.join}

	ruleargs = (argsOpt)=>[ Args[ :name {_Local(name) }]* ]
	
	
	argsOpt = ~_  _args('(',')'):r { r+[',']}=>[procargs] 
          | {[]}

	procargs = {@@ary=[];@@tmp=[]}
						 ( .:c &{c==','} {@@ary<<Args[{:ary=>@@tmp}];@@tmp=[]}
							 | procargs2
						 )*
						 {@@ary}
	
	procargs2 =	Args[ procargs2* ]
						| .:a {@@tmp<<a}


	args(o,c) = _args(o,c):r -> Args[{:ary=>([o]+r+[c])}]

	_args(o,c) = seq(o) "" rubyarg*:r seq(c) -> r
		
	rubyarg  = '`' expression:e '`' -> Lambda[_body(e)]
           | args('(',')')	| args('[',']') | args('{','}')
					 | interpolated:s      -> Strin[connectstring(['"']+s+['"'])]
					 | '\'' until("'" ):s  -> Strin[connectstring(["'"]+s+["'"])]
					 | ('...' | '..')
					 | ( ":@":n[] | <$.:>:n[] )? ~_ name:n[] -> n.join
					 | key
					 | <^`'"(){}\[\]>

	until(e) = ( seq(e) break 
             | ('\\':x[])? .:x[]
             )* -> x

	interpolated = '"' ( '"' break 
             | args('#{','}'):x[]
             | ('\\':x[])? .:x[]
             )* -> x

	
	inline_host_expr = _args('{','}'):r {Act[Args[{:ary=>r}]]}
	host_expr = inline_host_expr 
						| '->' line:s   {"{"+s+"}"}=>[ inline_host_expr ]	
}
