makeclasses(Object,
    [:Args,:o,:c,:r],
    [:Key,:name,:expr,:args],
    [:Result,:name,:expr,:args,:vars],
    :Apply,:Char,
    :Nested,
    :Exp,
    [:Set,:name,:expr,:append],
    [:Many,:o],
    :Many1,
    :Comment,
    [:Act,:uses,:pred,:actno],
    :Lookahead,
    :Not,
    :And,
    :Or,
    :Seq,
		[:Strin],
		[:Local,:number,:no],
		[:Pass,:var,:to,:enter],
    [:Rule,:name,:args,:locals,:body,:reachable],
    [:Grammar,:name,:parent,:rules,:rbcode,:rbno],
		:Local,:Global,
		:Memo,
		:Break,
		:Cut,
		:Stop
)
class Local
	def inspect
		"Local[#{ary[0]}_#{number}]"
	end
end
def quote(s)
  s=s*""
  '"'+s.gsub('\\"','"').gsub('"','\\"')+'"'
end

$av=0
def autovar
	$av+=1
	_Local("autovar",$av)
end

def _Enter(from,to)
	_Pass(from,to,true)
end
def _Pass(from,to,enter=false)
	a=autovar
	Seq[_Set(a,from), Pass[{:to=>to,:enter=>enter,:var=>a}]]
end


def _Set(name,expr,append=false)
  Set[{:name=>_Local(name),:expr=>expr,:append=>append}]
end
def _Append(name,expr)
  _Set(name,expr,true)
end

def _Many(expr,many1=false)
  a=autovar
  Seq[{:ary=>( [_Set(a, _Act("[]"))]+(many1 ? [_Append(a,expr)] : [])+[Many[{:ary=>[_Append(a,expr)],:o=>autovar}],_Act(a)])}]
end
def _Many1(expr)
  _Many(expr,true)
end

def _Act(expr,pred=false)
  Act[{:ary=>[expr],:pred=>pred}]
end
def _Pred(expr)
  _Act(expr,true)
end
def _body(body)
	Seq[_Set("_result",body), _Act(_Local("_result"))]
end

$varhash=Hash.new{|h,k| h[k]={}}
	def _Local(name,number=1)
		return name if name.is_a? Local
		if var=$varhash[name][number]
			instance_eval{	@locals << var if @locals}
			var
		else
			$varhash[name][number]=Local[{:ary=>[name],:number=>number}]
			_Local(name,number)
		end
	end


amethyst AmethystParser < Amethyst{
	igrammar = ((~'amethyst'   . )+:{it*""} | grammar)*:a -> a

	grammar = "amethyst" name:name ("<" name:parent |empty {parent="Amethyst"} ) 
"{" rule*:rules "}"  @Grammar
	
  rule = {@@locals=[]} 
				 name:name  ruleargs:args "=" expression:body  
	   		 {_body(body)}:body {@@locals.uniq}:locals	 @Rule

	expression = choice
	
	choice = listOf('sequence',`"|"`):ary @Or
	
	sequence =  (nr prefixed)*:ary  @Seq

  prefixed   = "~" prefixed:m -> Not[m]
             | "&" inlineHostExpr:expr  -> _Pred(expr)
             | "&" ~inlineHostExpr:expr  prefixed:m -> Lookahead[m]
						 | modifier:from (  '=>' modifier:{from=_Pass(from,it)}      optIter(from):from (~space binding(from):from)*
												     | '[' expression:{from=_Enter(from,it)} "]" optIter(from):from (~space binding(from):from)*
														 )* {from}

 		modifier = term:t optIter(t):t  (~space binding(t):t)* -> t
             | binding(Apply["anything"])
             | "#" (~endline .)*:c -> Comment[c]

   optIter(t) = "*"  -> _Many(t)
              | "+"  -> _Many1(t)
              | "?"   -> Or[t,Apply["empty"]]
              | empty -> t
  
	binding(exp) = {exp}:expr ":"  name:name ('[]' {true} | empty {false} ):append ->_Set(name,expr,append)
               | ":" inlineHostExpr:e -> Seq[ _Set("it",exp) , _Act(e) ]


	term  =  className:cls -> Apply["clas",cls]
				| "nested" '(' expression:expr ")" -> Nested[expr]
		 	  | application
 			  | key
			  | ("->" atomicHostExpr | "" inlineHostExpr):x    ->  _Act(x)
				| "\"" (~'"' eChar)*:s '"' -> Apply["token" ,quote(s)]
		 	  | "'"  (~'\''  eChar)*:s '\''  -> Apply["seq",quote(s)]
 			  | number:{Apply["exactly",it]}
      	| "<" (~">" eChar)+:x  ">"                            ->  Apply["regch","/[#{x}]/"]
        | "[" expression:to "]" -> _Enter(Apply["anything"],to)
		    | "(" expression:x ")" ( '[]'	collect(x) | empty {x} )

	application =  "." -> Apply["anything"]
                 | (name:klas '::' name:rule {[klas,rule]} | name):rule argsOpt('(',')'):arg -> Apply[rule,arg]

	key         = "@" className:name  argsOpt('[',']'):args  @Result
              | "@" name:name   @Key

  collect(ors) = -> a=autovar; Seq[Or[{:ary=>ors.ary.map{|ands| Seq[{:ary=>ands.ary.map{|expr| _Append(a,expr)}}]}}],_Act(a)]

	eChar = '\\' char:c   -> "\\#{c}"
  	  	| _args('#{','}')
				| char

	ruleargs = (argsOpt('(',')'))=>[addargs]

	addargs= Args[ :name {_Local(name) }:result[] ]* -> result || []

	
	nr = ~(name argsOpt('(',')') "=")
	
	argsOpt(o,c) = args(o,c) 
                | empty -> []

	args(o,c) = __args(o,c):r {
							r<< ','
							ary=[]
							tmp=[]
							r.each{|a|
								if a==','
									ary<<Args[{:ary=>tmp}];tmp=[]
								else
									tmp<<a
								end
							}
							ary
						}

	_args(o,c) = __args(o,c):r -> Args[{:ary=>([o]+r+[c])}]

	__args(o,c) = seq(o) "" rubyarg*:r seq(c) -> r
		
	rubyarg  = '`' expression:e '`' -> Exp[_body(e)]
           | _args('(',')')					 | _args('[',']')					 | _args('{','}')
					 | '"' (~'"'   eChar)*:s '"'  -> Strin[['"']+ s+['"']]
					 | '\''(~'\''  eChar)*:s '\'' -> Strin[['\'']+s+['\'']]
					 | ( <$.:>:n[] | empty) <a-zA-Z_>+:n[] -> n*""
					 | '@@' <a-zA-Z_>+:n[] -> Global[n*""]
					 | key:k -> Key[k] 
					 | <^`{}()'"\[\]>

	nameFirst      = <_$^> | letter

  nameRest       = nameFirst | digit

  className      = _* (upper nameRest* )[]:{leterize(it*"")}
	
	name = _* (nameFirst nameRest*)[]:{leterize(it*"")}

	inlineHostExpr = args('{','}')

	number = <0-9>+

	atomicHostExpr = (~endline .)*:s   {"{#{s*""}}"}=>[ inlineHostExpr ]
}
