amethyst AmethystTranslator < Amethyst {	
	itrans = [ (char | trans)*:r ] -> r*""
	
	trans = Grammar[rw('return',`@name:name @parent:parent @rules=>transs:body`)] -> "class #{name} < #{parent}\n#{body}\nend\n"
				| Rule[@name:name @locals:{@@locals=it} @args=>args:argss @body=>trans:body] -> "def #{name}(#{argss}) \n#{@locals.map{|l|l+"=nil"}*";"}\n #{body} \nend\n"
				| Enter[trans:expr] failwrap("_enter{#{expr}}")
				| Or[rw('next', `transfn*:ors`)]  failwrap("_or(#{ors*","})")
				| And[trans*:t ] -> "#{t*"\n"} "
				| Not[rw('next',`trans:t`) ]  failwrap("_not{#{t}}")
				| Pred[args:t ]  failwrap("(#{t})||FAIL")
				| Act[args:t ] -> t
  			| Lookahead[rw('next',`trans:t`) ]  failwrap("_lookahead{#{t}}")
        | Comment[:c] -> ""
				| Many[rw('break', `trans:t` ) @o:o] -> "while true\n#{o}=@input;r=#{t}\n break FAIL if r==FAIL\nend;@input=#{o}"
				| Apply[ :name args:argss]  failwrap("#{name}(#{argss})")
        | Set[@name:name @expr=>trans:expr] -> "#{name.to_s} = (#{expr})"
				| Append[@name:name @expr=>trans:expr] -> "it=(#{expr})\n #{name}||=[];_append(#{name},it)"
				| Resul[@name:name @args=>args:argss @vars:vars] -> "#{name}[#{argss} {#{vars.map{|l| ":#{l}=>#{l}"}*","} }]"
				| Foreign[@klas:klas @rule=>rule @args=>args:argss] failwrap("_foreign(#{klas}).#{rule}(#{argss})")
				| Key[@name:name] -> "_key(:#{name})"
				| Pass[@to=>trans:to] failwrap("_pass(it){#{to}}")
				| Shadow[@name:name @expr=>trans:expr @a:a] ->  "#{a}=#{name} ;it=(#{expr});#{name}=#{a};it"

	transfn = trans:t -> "proc{#{t}}" 
	
	transs = [ trans*:t ] -> t
	
	args = Array[arg*:a] -> a*","
       |  arg*:a -> a*","
	
	arg = Args[arg*:a] -> a*""
			| Exp[transfn:t ] -> t
		  | ExpKey[ trans:t] -> t
			| anything
	
	rw(word,prc) = {rwo=@@returnword;@@returnword=word} apply(prc):x {@@returnword=rwo;x}

	failwrap(s) = {  "(it=(#{s});#{@@returnword} FAIL if it==FAIL;it)" }
}
