def varname(vh,name,number)
	 vh[name][number]=vh[name].size+1 if !vh[name][number]
	 "#{name}_#{vh[name][number]}"
end
amethyst AmethystTranslator < Amethyst {	
	
	itrans =  (char | trans)*:r  -> r*""
	
	trans = Grammar[@name:name @parent:parent @rules=>transs:body] -> "class #{name} < #{parent}\n#{body}\nend\n"
				| Rule[ { @@varhash=Hash.new{|h,k| h[k]={}}  } 
								rw('return',`@name:name @args=>args:argss @body=>trans:body`) { "def #{name}(#{argss})\n #{@@varhash.select{|nam,b| (nam!="autovar") && (!@args.map{|l| l[0]}.include?(nam))}.map{|nam,b| b.map{|bi,no| "#{varname(@@varhash,nam,bi)}=nil\n"}}.sort*""} it=nil\n#{body} \nend\n"}]
				| Or[rw('next', `transfn*:ors`)]  failwrap("it=_or(#{ors*","})")
				| Seq[trans*:t ] -> "#{t*"\n"} "
				| Act[args:t @pred:pred] -> pred ?  failwrap("it=(#{t})||FAIL") : "it=(#{t})"
  			| Lookahead[ @neg:neg rw('next',`trans:t`) ]  failwrap("it=_lookahead(#{!!neg}){#{t}}")
        | Comment[:c] -> ""
				| Many[rw('break', `trans:t` ) @o=>arg:o] -> "while true\n#{o}=@input;r=#{t}\n break FAIL if r==FAIL\n (#{o}=@input;@stop=nil;break FAIL) if @stop==true\nend;@input=#{o}"
				| Apply[ Array[:klas :name] args:argss]  failwrap("it=_foreign(:#{ name } #{ argss!=[] ? ",#{argss}" : "" })")
				| Apply[ :name args:argss]  failwrap("it=#{name}(#{argss})")
				| Set[@name=>arg:name @expr=>trans:expr @append:append] -> "#{expr}\n" + (append ? "#{name}||=[];_append(#{name},it)" : "#{name} = it")
				| Result[@name:name @args=>args:argss @vars:vars] -> "it=#{name}.create(#{argss} {#{vars.map{|l| ":#{l[0]}=>#{varname(@@varhash,l[0],l[1])}" }*","} })"
				| Key[@name:name] -> "it=self['#{name}']"
				| Local[:name :number] ->"it="+ varname(@@varhash,name,number)
				| Global[:name] -> "it=@#{name}"
				| Pass[rw('next',`@to=>trans:to @var=>arg:var @enter:enter`)] failwrap("it=_pass(#{!!enter},#{var}){#{to}}")
				| Cut[] ->  "@cut=true;it"
				| Stop[] -> "@stop=true;it"

	transfn = trans:t -> "proc{#{t}}" 
	
	transs = [ trans*:t ] -> t
	
	args = Array[arg*:a] -> a*","
       |  arg*:a -> a*","
	
	arg = Args[arg*:a] -> a*""
			| Strin[arg*:a] -> a*""
			| Exp[transfn:t ] -> t
			| Key[@name:name] -> "@src.#{name}"
			| Local[:name :number] -> varname(@@varhash,name,number)
			| Global[:name] -> "@#{name}"
			| anything
				
	rw(word,prc) = {rwo=@@returnword;@@returnword=word} apply(prc):x {@@returnword=rwo;x}

	failwrap(s) = {  "#{s};#{@@returnword} FAIL if it==FAIL" }
}
