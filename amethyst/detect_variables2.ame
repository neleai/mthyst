amethyst Analyze_Variables2 < Traverser_Clone2 {
	itrans =   (Grammar[ @rules=>[ Rule[root]*:rules ] {@rules=rules} @self] | .)*
  root = @self=>Rule[ {@@bnding=@bnding} {@@variables=Hash.new{|k,v| k[v]=v} ;(@locals+@args).each{|w| @@variables[w[0]]=w}} {@@locals=@locals} 
traverse[.*	{@locals=nil} @self] ]

	visit = Args[ traverse[.* {@ary.map{|aa| @@variables[aa] }}=>[flat:a]  {@ary=connectstring(a.flatten)}  {(@ary.size==1&&(@ary[0].is_a?(Local)||@ary[0].is_a?(Global)||@ary[0].is_a?(Key))) ? @ary[0] : @self}]]
				| Act[ traverse[.* @ary=>[( Local)] ] ]
				| Result[ {vars=@@locals.select{|aa| @vars.include? aa[0].to_sym}.uniq ;Result[{:name=>@name,:vars=>vars}]}]
				| Or[ traverse_item*:t {Or[*t]} ]
				| Seq[ traverse_item*:t {Seq[*t]} ]


	flat= (Args[flat] | Strin[flat] |	. )*
}

amethyst Remap_Acts < Traverser_Clone{
	root = traverse
	
	visit = Act[traverse_item*:ar  {@pure ? PureAct[ar] : Act[ar,@pred]} ]
				| Or[ traverse_item*:t {Or[*t]} ]
				| Seq[ traverse_item*:t {Seq[*t]} ]
				| Pass[ @to=>traverse_item:to {Pass.create({:to=>to,:var=>@var}).normalize} ]
				| Bind[ @name=>traverse_item:name @expr=>traverse_item:expr {Bind.create({:name=>name,:expr=>expr}).normalize} ]
				| Many[ traverse_item*:t {Many.create({:ary=>t}).normalize} ]

				| Apply[ traverse_item*:t {Apply[*t]} ]
				| (CAct | Bnding | Global | Key| Result)[.*{@self}]
}
