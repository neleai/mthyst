amethyst AmethystRBTranslator < Traverser{
	root = Grammar[  {@@rbcode="require '#{@name}'\nclass #{@name}\n";@@rbno=0} traverse  {@rbcode=@@rbcode+"\nend";@rbno=@@rbno} @this]

	visit = Act[rbtrans:a {@@rbcode<<"def callback#{@@rbno}\n #{a}\nend\n"; @actno=@@rbno;@@rbno+=1 }   traverse]
				| Result[]

	rbtrans =  Args[rbtrans*:a] -> a*""
		      | Strin[rbtrans*:a] -> a*""
					| Key[ :name] 									 -> " key[#{name}]"
    		  | Local[:name @no:number] -> " self[#{number}]"
     			| Global[:name] 								 -> " @name"
					| String
					| Array[ rbtrans*:a ] -> a*""
}

amethyst AmethystCTranslator < Amethyst {	
	trans = Grammar[ @name:name @rules=>[trans*]:t @rbno:rbno ] 
				{ s="#include \"cthyst.h\"\nVALUE cls_#{name}"; 
          rbno.times{|i| s<<",callback#{i}"}; s<<";"; s<<(t*"\n") ; 
          s<<"\nvoid Init_#{name}(){ cls_#{name}=rb_define_class(\"#{name}\",rb_cObject); "; 
          rbno.times{|i| s<<"callback#{i}=rb_intern(\"callback#{i}\");"};
          s<<" init_clas(cls_#{name}); }"; s }
			  | Rule[{@@labelno=0; @@faillabel="fail"} @name:name @body=>trans:body {@locals.size}:bindings {bindings-@args.size}:lvars ] 
          { "int #{name}(cstruct *ptr){VALUE result; 
                         addbinding(ptr,#{bindings});initbinding(ptr,#{lvars}); 
                         #{body} \n 
                         rmbinding(ptr,#{bindings}); return 0; \n 
                         fail: rmbinding(ptr,#{bindings}); return 1; }" }
				| Seq[trans*:t ] -> "#{t*"\n"} "

				| Cut -> "cut=1;"
				
				| Not[{@@labelno+=1}:ln rw("not#{ln}",`trans:t`) {"#{t} goto #{@@faillabel}; not#{ln}:;"}  ]
				
				| Or[{@@labelno+=1}:ln {0}:on rw('',`({on+=1} rw("or#{ln}_#{on+1}",`trans`) )*:t`) ] {on=0; "{ int oldpos=ptr->pos;int cut=0;\n#{(t+["goto #{@@faillabel};"]).map{|i| on+=1;"or#{ln_1}_#{on_1}: ptr->pos=oldpos; if(cut) goto #{@@faillabel}; #{i}; goto success#{ln_1};\n" }*""} success#{ln}:; }"}

				| Act[:act @pred:pred @actno:actno] -> "result=rb_funcall(ptr->obj,callback#{actno},0);" + ( pred ? "if (!RTEST(result)) goto #{@@faillabel};" : "" ) 
				
				| Stop ->	"stop=1;"
				| Many[ trans:t ] ->  "{int stop=0; while(!stop){\n #{t} \n} }"
		
				| Apply[:name trans*:args ] -> s="";args.each_with_index{|a,i| s<<"#{a} csetarg(ptr,#{i+1},result);" };   s+"if (#{name}(ptr)) goto #{@@faillabel};result=result_of_apply(ptr);"

				| Char[:c] -> "if (ptr->str[ptr->pos]!='#{c}') goto #{@@faillabel};ptr->pos++;"

				| Set[ @name=>Local[ :number @no:number] @expr=>trans:expr ] -> "#{expr} csetlocal(ptr,#{number},result);"

				| String:s -> "result = rb_str_new2(\"#{s}\");"

			  rw(word,prc) = {@@faillabel}:rwo {@@faillabel=word } apply(prc):x {@@faillabel=rwo; x }
}
