amethyst AmethystRBTranslator < Traverser{
	root = Grammar[  {@@rbcode="require '#{@name}'\nclass #{@name}\n";@@rbno=0} traverse  {@rbcode=@@rbcode+"\nend";@rbno=@@rbno} @this]

	visit = Act[rbtrans:a {@@rbcode<<"def callback#{@@rbno}\n #{a}\nend\n"; @actno=@@rbno;@@rbno+=1 }   traverse]

	rbtrans =  Args[arg*:a] -> a*""
		      | Strin[arg*:a] -> a*""
					| Key[ :name] 									 -> " key['#{name}']"
    		  | Variable[:name @number:number] -> " variable['#{name}_#{number}']"
     			| Global[:name] 								 -> " global['#{name}']"
					| String
}
amethyst AmethystCTranslator < Amethyst {	
	trans = Grammar[ @name:name @rules=>[trans*]:t @rbno:rbno ] -> s="#include \"cthyst.h\"\nVALUE cls_#{name}"; rbno.times{|i| s<<",callback#{i}"}; s<<";"; s<<(t*"\n") ; s<<"\nvoid Init_#{name}(){ cls_#{name}=rb_define_class(\"#{name}\",rb_cObject); "; rbno.times{|i| s<<"callback#{i}=rb_intern(\"callback#{i}\");"};s<<" rb_define_method(cls_#{name},\"parse\",t_parse,1); }"; s
			  | Rule[{@@labelno=0; @@faillabel="fail"} @name:name  @body=>trans:body ] -> "int #{name}(cstruct *ptr){ #{body} \n return 0; \n fail:return 1; }"
				| Seq[trans*:t ] -> "#{t*"\n"} "

				| Cut -> "cut=1;"
				| Or[{@@labelno+=1}:ln {0}:on rw('',`({on+=1} rw("or#{ln}_#{on+1}",`trans`) )*:t`) ] {on=0; "{ int oldpos=ptr->pos;int cut=0;\n#{(t+["goto #{@@faillabel};"]).map{|i| on+=1;"or#{ln_1}_#{on_1}: ptr->pos=oldpos; if(cut) goto #{@@faillabel}; #{i}; goto success#{ln_1};\n" }*""} success#{ln}:; }"}

				| Act[:act @pred:pred @actno:actno] -> f="rb_funcall(ptr->obj,callback#{actno},0)"; pred ? "if (!RTEST(#{f})) goto #{@@faillabel};" : f+";"
				
				| Stop ->	"stop=1;"
				| Many[ trans:t ] ->  "{int stop=0; while(!stop){\n #{t} \n} }"
				
				| Apply[:name ] -> "if (#{name}(ptr)) goto #{@@faillabel};"

				| Char[:c] -> "if (ptr->str[ptr->pos]!='#{c}') goto #{@@faillabel};ptr->pos++;"
	  rw(word,prc) = {@@faillabel}:rwo {@@faillabel=word } apply(prc):x {@@faillabel=rwo; x }
}
