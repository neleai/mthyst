#@Or_AST and @Seq are necessary for collect
#
class AmethystParser_Highligth < Amethyst
	def local(x)
		x.is_a?(String) ? (l=Local[x,@bnding];@locals<<l;l) : x
	end
end

amethyst AmethystParser_Highligth {
  withcolor(color,lam) = {pos}:oldpos apply(lam):r {oldpos.upto(pos-1){|i| $colors[i]||=color};r}

  file     = ( (~'amethyst'   . )+:{it.join}
             | grammar
             | "`" expression '`'
             )*

  grammar = withcolor("red",` "amethyst"`) "" name:name ("<" "" name  |{"Amethyst"}):parent  
"{" rule*:rules "}"  @Grammar
  
  rule = {@@locals=[];@@appends=[];@@bnding=Bnding[]} {@@bnding}:bnding  
         "" name:name  ruleargs:args "=" expression:body  
          {Bind[local("_result"),body]}:body {@@locals.uniq}:locals {body=Seq[{:ary=>(@@appends.uniq.map{|a| Bind[a,Act["[]"]]}+[body])}]; }   @Rule

  
  expression = listOf(`sequence`,`"|"`):ary @Or_AST  
  sequence =  (nr ","? "" prefixed)*:ary  @Seq
  nr = ~("" name argsOpt "=")

  prefixed   = <&~>:neg inline_host_expr:expr-> Pred[expr[0],neg=="~"]
             | <&~>:neg prefixed:m    -> Lookahead[m,neg=="~"]
             | postfixed

  postfixed =  term:from 
                    (~_     ( '=>'     term:e           -> Pass_AST[from,e] 
                            |withcolor("blue",` '['      expression:e "]"`) -> Enter_AST[from,e]
                            | <+*>:one -> Many[from,one=="+"]
                            | '?'      -> Or_AST[from,Apply["empty"]]
                            | withcolor("yellow",`':' '[' (key | name):name ']'`) ->  @@appends<< local(name); Append_AST[local(name),from]
                            | withcolor("yellow",`':'`) ( withcolor("yellow",` (key | name):name ('[]'?):append`)  -> @@appends<< local(name) if append; append=='[]' ? Append_AST[name,from] : Bind[local(name),from]
                                  | inline_host_expr:e                      -> Seq[ Bind[local("it"),from] , Act[e] ]
                                  ) 
                    ):from  )* {from}

  
  cases = className:clas  ~'::'                      -> Apply["clas",clas]
        | ((number ('...'|'..') number)[]:{it.join} | number):num -> Apply["member",num.to_s]
        | '<'  until('>' ):s -> Apply["regch","/["+s+"]/"]

  term  = 'nested(' expression:expr ")" -> Nested[expr]
        | 'break' -> Seq[Cut[],Stop[]]
        | cases
        | withcolor("red",`call`)
        | &<.:> '.'? -> Apply["anything"]
        | '[' expression:e "]" -> Enter_AST[Apply["anything"],e]
        | key:{Act[it]}
        | host_expr
        | '"'  until('"' ):s -> Apply["token" ,quote(s)]
        | '\'' until('\''):s -> Apply["seq"   ,quote(s)]
        | '#'  line:s        -> Comment[s]
        | '(' expression:x ")" ( '[]'  collect(x) | {Parenthesis[x]} )

  collect(ors) = -> a=autovar; Seq[Or_AST[{:ary=>ors.ary.map{|ands| Seq[{:ary=>[Bind[a,Act["[]"]]]+ands.ary.map{|expr| Append_AST[a,expr]}}]}}],a]
  
  call = className:klas '::' name:name argsOpt:arg -> Apply[[klas,name],arg]
       |                     name:name argsOpt:arg -> Apply[name,arg]
 
  key         = '@' className:name             -> Result[{:name=>name}]
              | '@'      name:name argsOpt:arg -> Key[name,arg]
              | '@@'     name:name             -> Global[name]
              | '@>'     name:name             -> Contextual_Argument[name]
              | '@<'     name:name             -> Contextual_Return[name] 

  name           =  (<_a-zA-Z> <_a-zA-Z0-9>*)[]:{it.join}
  className      =  (    <A-Z> <_a-zA-Z0-9>*)[]:{it.join}

  ruleargs = (argsOpt)=>[ Args[ :name {local(name) }]* ]
  
  
  argsOpt = ~_  _args('(',')'):r { r+[',']}=>[procargs] 
          | {[]}

  procargs = {@@ary=[];@@tmp=[]}
             ( .:c &{c==','} {@@ary<<Args[{:ary=>@@tmp}];@@tmp=[]}
               | procargs2
             )*
             {@@ary}
  
  procargs2 =  Args[ procargs2* ]
            | .:a {@@tmp<<a}


  args(o,c) = _args(o,c):r -> Args[{:ary=>([o]+r+[c])}]

  _args(o,c) = seq(o) "" rubyarg*:r seq(c) -> r
    
  rubyarg  = '`' expression:e '`' -> Lambda[Bind[local("_result"),e]]
           | args('(',')')  | args('[',']') | args('{','}')
           | '"' interpolated("\""):s      -> Strin[['"']+s+['"']]
           | <a-z0-9_>:e '<<' -> [e,'<<']
           | '\'' until("'" ):s  -> Strin[["'"+s+"'"]]
           | ('...' | '..')
           | ( ":@":[n] | <$.:>:[n] )? ~_ name:[n] -> n.join
           | key
           | <^`'"(){}\[\]>

  
  interpolated(e) =  ( seq(e) break 
             | args('#{','}'):[x]
             | ('\\':[x])? .:[x]
             )* -> x

  
  inline_host_expr = _args('{','}'):r {Act[Args[{:ary=>r}]]}
  host_expr = inline_host_expr 
            | '->' line:s   {"{"+s+"}"}=>[ inline_host_expr ]  

}

