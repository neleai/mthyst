persistence
make AmethystModule +include to mimic ruby module
parser to produce literal tree and convert to abstract tree
make position handling explicit as in amethyst/position.ame


bind cut to corresponding or
Add id of cut to or

code motion of acts and binds
dataflow for pureness (alias analysis with trackable host language)

documentation

rules that use lambda access bind otherwise use local variables
unify lambda+rule in ctranslator2
analysis what closures can be saved on stack


rewrite using backtracking,repeat until...
continuation passing style


optimalization of lookaheads such that x* ~x the ~x is automaticaly satisfied(aka eof)
in ~space space* the  space* must be empty (predication to fail)
Do it by constant propagation?

Automaticaly rewrite .* foo to _find(`foo`) and optimalizations
Special case _find(`eof`) consumes everything

adaptive dataflow
think about suitable decomposition
cont passing style.
pseudoprocedures 

serialization
incremental compilation
assumptions

support for provable refactorization and migrations

functor for case insensivity

extract cc from makefile for portability

UTF8

grammar not necessary

flatarray class
done but too slow to use

rewrite rigth recursion by futures
like reversing single linked list


dataflows to calculate bitmasks and test by (chars|both =ones|both) where ones are bits that must be 1 and both bits than can be 0 or 1
indexing from end
integrate regch with llmatch
dataflow compute first 8 characters

switch for ints,true,false,nil    # no use case yet

recognize block-scoped locals
recognize local=

paralelize compilation   # how log for testing purposes?
compile to c at background

separate dataflow and dead code elimination

predicated inlining
parametrization 
inlining concrete and general form
can use overaproximation from more general form?
copy propagation, expression variables
Constant propagation also do value numbering to register renaming scheme.

cache dataflow data with objects

predication of sizes

simple dataflows
string_only,object_only
as constant propagation?

? warn about a:b(c)

at class level use one hash for determining class numbers? perhaps slower with inheritance

left factor inside normalization of or

local DCE?

as pass Apply takes only locals as arguments.

@>parents contextual argument

ask classes directly about properties

try speed vs various other parsers.

parametrize traverser and visitor

optimize pass when value is only read by anything
simplify =>Class[ sth ] pattern
slice analysis
also destructure and access arrays

origin tracking string
buffers

memoization use write-back cache.

do not use apply, use lambdas and match instead

implement eval
