persistence
optimizer simplifying =>[ ] to []
split to separate parser and traverser 
make AmethystModule +include to mimic ruby module
parser to produce literal tree and convert to abstract tree
make position handling explicit as in amethyst/position.ame

generic parent(Class) in tree traversal
variable cget,cset,rbget,rbset or some other generalization
consider pseudovariables

bind cut,stop to corresponding many,or
Add id of cut stop to many/or

code motion of acts and binds

documentation

unify lambda+rule in ctranslator2
rewrite using backtracking,repeat until...
continuation passing style

switch and predication by constant propagation?
predication by splitting to predicated and notpredicated part

consider left factor when conditions are in inclusion.

optimalization of lookaheads such that in anything* ~anything the ~anything is automaticaly satisfied(aka eof)
in ~space space* the  space* must be empty (predication to fail)
Do it by constant propagation?

Automaticaly rewrite .* foo to _find(`foo`) and optimalizations
Special case _find(`eof`) consumes everything

adaptive dataflow
think about suitable decomposition
cont passing style.

dataflow cantfail, noresult
as constant propagation

serialization
incremental compilation

support for provable refactorization and migrations

functor for case insensivity

copy propagation, expression variables
Constant propagation also do value numbering to register renaming scheme.

analysis what closures can be saved on stack

replace({"a"=>"b","c"=>"d"})

dataflows to calculate bitmasks and test by (chars|both =ones|both) where ones are bits that must be 1 and both bits than can be 0 or 1
indexing from end

extract cc from makefile for portability

UTF8

grammar not necessary

flatarray class

recognize local=

default arguments?

rewrite rigth recursion by futures
like reversing single linked list

assumptions

integrate regch with llmatch

pass for objects that dont need ary(convention not using .?)

switch for ints,true,false,nil
