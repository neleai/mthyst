persistence
optimizer simplifying =>[ ] to []
make AmethystModule +include to mimic ruby module
parser to produce literal tree and convert to abstract tree
make position handling explicit as in amethyst/position.ame


bind cut to corresponding or
Add id of cut to or

code motion of acts and binds
dataflow for pureness (alias analysis with trackable host language)

documentation

unify lambda+rule in ctranslator2
analysis what closures can be saved on stack
rewrite using backtracking,repeat until...
continuation passing style


optimalization of lookaheads such that x* ~x the ~x is automaticaly satisfied(aka eof)
in ~space space* the  space* must be empty (predication to fail)
Do it by constant propagation?

Automaticaly rewrite .* foo to _find(`foo`) and optimalizations
Special case _find(`eof`) consumes everything

adaptive dataflow
think about suitable decomposition
cont passing style.
pseudoprocedures 

serialization
incremental compilation

support for provable refactorization and migrations

functor for case insensivity

copy propagation, expression variables
Constant propagation also do value numbering to register renaming scheme.

extract cc from makefile for portability

UTF8

grammar not necessary

flatarray class
done but too slow to use

default arguments?

rewrite rigth recursion by futures
like reversing single linked list

assumptions

dataflows to calculate bitmasks and test by (chars|both =ones|both) where ones are bits that must be 1 and both bits than can be 0 or 1
indexing from end
integrate regch with llmatch

pass for objects that dont need ary(convention not using .?)

switch for ints,true,false,nil

recognize block-scoped locals
recognize local=

paralelize compilation

separate dataflow and dead code elimination

predicated inlining
inlining concrete and general form
can use overaproximation from more general form?

cache dataflow data with objects

predication of sizes

simple dataflows
string_only,object_only
as constant propagation?

? warn about a:b(c)

at class level use one hash for determining class numbers? perhaps slower with inheritance

labels use hash of body do decrease changes

apply["success"] instead of placeholder?

left factor inside normalization of or

local DCE?

simplify =>Class[ sth ] pattern

as pass Apply takes only locals as arguments.

@>parents contextual argument

ask classes directly about properties

try speed vs various other parsers.

highligth local variables
