class Amethyst2RegReg < Amethyst
  def localnumber(name)
    @locals||=["_result"]
    @locals << name if !@locals.index(name[0])
    @locals.index(name[0]) 
  end
end
amethyst Amethyst2RegReg {
  trans = Rule[ {@@locals=["_result"];@@stops=1} @body=>trans:body @name:name ] -> Rrule.create({:name=>name,:locals=>@@locals.size,:body=>body})
        | Seq[ trans:head (.+:tail ({Seq[*tail]}=>trans):tail)? ] -> tail ? Rseq.create({:head=>head,:tail=>tail}) : head
        | Or[ trans:head  (.+:tail ({ Or[*tail]}=>trans):tail)? ] -> tail ? Rswitch.create({:head=>head,:alts=>[tail,nil]}) : head
        | Lookahead[ trans:e ] -> Rswitch.create({:head=>e,:alts=>[Rcall.create({:name=>"fail"}),Rcall.create({:name=>"empty"})]})
        | Apply[ ["nested"] CAct[ .:start ] CAct[ .:middle ] CAct[ .:end ] ] -> Rnested.create({:body=>RSeq[Rcall.create({:name=>start}),Rcall.create({:name=>middle}),Rcall.create({:name=>end})]})
        | Apply[ ["seq"] CAct[ .:s ] ] -> Rchar.create({:str=>s})
        | Apply[ .:name eof ] -> Rcall.create(:name=>name)
        | Many[ {@@stops||=1;@@stops*=2} trans:e {@@stops/=2} ]     -> Rmany.create({:stops=>@@stops,:body=>e})
        | Stop[ ]                                       -> Rstop.create({:stops=>@@stops/2})
        | Act[ String["_append("] ]   -> Ract.create(:arg=>'nul')
        | Act[ transrb*:cb  ]         -> Ract.create(:arg=>addcb(cb.join))
        | Bind[ @name:n trans:t ]     -> RSeq[t,Rbind.create({:var=>localnumber(n.ary)})]
        | CAct[   ]           -> Ract.create(:arg=>'nul')
        | Local[  ]           -> Ract.create(:arg=>'nul')
        | .:x -> puts "f",x.inspect;raise "unrecognized"

  transrb = Local[ { "closure[#{localnumber(@ary)}]" } ]
          | Key[ .:name ] -> "@#{name}"
          | .
}
