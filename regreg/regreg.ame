class Amethyst2RegReg < Amethyst
  def localnumber(name)
    @locals||=[]
    @locals << name if !@locals.index(name)
    @locals.index(name) 
  end
  def rcall(name)
    Rcall.create(:name=>name,:argc=>0,:afrom=>[])
  end
end
amethyst Amethyst2RegReg {
  trans = Rule[ {@@locals=@args.map{|ar|ar.ary};@@stops=1} @body=>trans:body @name:name ] ->puts @@locals.inspect; Rrule.create({:name=>name,:locals=>@@locals.size,:body=>body})
        | Seq[ trans:head (.+:tail ({Seq[*tail]}=>trans):tail)? ] -> tail ? Rseq.create({:head=>head,:tail=>tail}) : head
        | Or[ trans:head  (.+:tail ({ Or[*tail]}=>trans):tail)? ] -> tail ? Rswitch.create({:head=>head,:alts=>[tail,nil]}) : head
        | Lookahead[ trans:e ] -> Rswitch.create({:head=>e,:alts=>[rcall("fail"),rcall("empty")]})
        | Apply[ ["nested"] CAct[ .:start ] CAct[ .:middle ] CAct[ .:end ] ] -> Rnested.create({:body=>RSeq[rcall(start),rcall(middle),rcall(end)]})
        | Apply[ ["seq"] CAct[ .:s ] ] -> Rchar.create({:str=>s})
        | Apply[ .:name {[]}:arg {[]}:aact
                        ( .:x {autovar}:a {arg<<localnumber(a.ary)} {Bind[a,x]}=>trans:[aact] )* 
               ] -> RSeq[*(aact+[Rcall.create(:name=>name,:argc=>arg.size,:afrom=>arg)])]
        | Many[ {@@stops||=1;@@stops*=2} trans:e {@@stops/=2} ]     -> Rmany.create({:stops=>@@stops,:body=>e})
        | Stop[ ]                                       -> Rstop.create({:stops=>@@stops/2})
        | Act[ {@@varsin=[]}  transrb*:cb  ]         -> puts @@varsin.inspect;  Ract.create(:arg=>addcb(cb.join),:varc=>@@varsin.uniq.size,:vars=>@@varsin.uniq)
        | Bind[ @name:n trans:t ]     -> RSeq[t,Rbind.create({:var=>localnumber(n.ary)})]
        | CAct[   ]           -> Ract.create(:arg=>'nul')
        | Local[  ]           -> Ract.create(:arg=>'nul')
        | .:x -> puts "f",x.inspect;raise "unrecognized"

  transrb = Local[ {@@varsin<<localnumber(@ary); "local(#{localnumber(@ary)})" } ]
          | Key[ .:name ] -> "@#{name}"
          | .
}
