// autogenerated see stack_machine.rc
#include "stack_machine.h"

<% require 'types.rb' %>
<%
# We started with recursive implementation and we handle call stack
# ourselves. 
# In recursive implementation we copied all arguments for each expression.
# In this implementation we use backtracking persistence to get equivalent 
# behaviour.
  $argh={};$stackstructs=[];$stackbody=[]
def stack_def(name,args)
  $argh[name]=args;
  $stackstructs<<"struct s_arg_#{name}{char type; #{args.map{|t,v| t+' '+v+';'}*""}};"
end 
def stack_push(name,*vals)
  args=$argh[name]
  raise "#{name} expects #{args.size} arguments." if vals.size!=args.size
  "{call_stack-=sizeof(struct s_arg_#{name});struct s_arg_#{name} *s=(struct s_arg_#{name} *)call_stack;s->type=TP_#{name}; #{args.size.times.map{|i| 's->'+args[i][1]+'='+vals[i]+';' }} }"
end
def stack_body(name,body)
  args=$argh[name]
  $stackbody<<"case TP_#{name}: {
    struct s_arg_#{name} *s=(struct s_arg_#{name} *)call_stack;
    #{args.map{|t,v| t+' '+v+'=s->'+v+';'}*""}
    call_stack+=sizeof(struct s_arg_#{name});
    #{body}
  break;}"
end
%>

<%
  stack_def( 'revert_local',[["long","no"],["void*","var"]])
  stack_body('revert_local',"a.closure->ary[no]=var;")
  [[$arg_tp,"a"],[$res_tp,"r"]].each{|vals,sc|
  vals.each{|t,v| 
    stack_def( "revert_#{sc}_#{v}",[[t,v]])
    stack_body("revert_#{sc}_#{v}","#{sc}.#{v}=#{v};")
  }
  }
  def revert_a(name);    stack_push("revert_a_#{name}","a.#{name}")  ;end
  def revert_r(name);    stack_push("revert_r_#{name}","r.#{name}")  ;end
%>
<%
%>
<%
$stackstructs<<"struct s_arg_exp{char type; exp *e;};"
def push_exp(e)
  "{call_stack-=sizeof(struct s_arg_exp); ;struct s_arg_exp *s=(struct s_arg_exp *)call_stack;s->type=#{e}->tp;s->e=#{e};}"
end
stack_def('cont_ended',[['struct cont_s *','cnt']])
stack_body('cont_ended',"a.cont=cnt->previous;conts=cnt-1;")
def push_cont_exp(e)
   "{struct cont_s *n=++conts; n->e=#{e}; n->previous=a.cont;
     if(n->e->forget) { exp_seq es; es.head=e->forget; es.tail=a.cont->cont_memo; n->cont_memo=normalize_seq(&es); } else { if (n->e==finish) n->cont_memo=finish; else n->cont_memo=a.cont->cont_memo;}
     a.cont=n; #{stack_push('cont_ended','n')}}"
end
def cont_call
  "#{push_exp('a.cont->e')} a.cont=a.cont->previous;"
end
$nodes.each{|n,a|
  stack_def(n,[["exp_#{n}*","e"]])
}
stack_body('seq',"#{push_cont_exp('e->tail')} #{push_exp('e->head')};")
stack_def('switch2',[["exp_switch*","e"]])
stack_body('switch',"#{stack_push('switch2','e')} memo_s mem=gl.memo_get(&gl,a.str,e->head,a.cont->cont_memo); if(mem.state!=-1) { r.state=mem.state; } else { #{push_exp('e->head')};} gl.alternatives+=1;")
stack_body('switch2',"memo_s mem; mem.state=r.state; gl.memo_set(&gl,a.str,e->head,a.cont->cont_memo,mem); if (e->alts->ary[r.state]){ #{push_exp('e->alts->ary[r.state]')} gl.alternatives-=1; }")
stack_body('char',"void *(*head)()=gl.head;void *(*advance)()=gl.advance;  if ((char) head(a.str)==*e->str) { #{revert_a('str')} a.str=advance(a.str); #{cont_call} } else { fail(); }" )
stack_body('finish', "free(call_stack_start);free(closures_start);free(conts_start); return a.closure->ary[0];")
stack_body('act',"{int i; for(i=0;i<e->vars->size;i++){#{stack_push('revert_local','e->vars->ary[i]','a.closure->ary[(long)e->vars->ary[i]]')}}} long(*fn)() =e->fn;if(fn(a.closure,gl.extra,e->arg)){#{cont_call}}")
stack_body('stop',"#{revert_a('stops')} a.stops|=e->stops; #{cont_call}" )
stack_body('many',"#{revert_a('stops')} if (e->stops & a.stops){
           a.stops=a.stops&(~e->stops);
           #{cont_call()}
         }else{
           #{push_cont_exp("e")}
           #{push_exp("e->body")}
         }")
stack_def('call_finished',[["exp_call_conted *","e"]])
stack_body('call'," exp *fin=call_conted(a.closure); #{push_cont_exp('fin')} #{stack_push('call_finished','fin')} struct closure_s *c=a.closure; a.closure=++closures; a.closure->size=e->body->locals;a.closure->ary=calloc(sizeof(void*),a.closure->size); 
int i; for(i=0;i<e->args->size;i++) a.closure->ary[i+1]=c->ary[(long) e->args->ary[i]];
#{push_exp('e->body->body')}")
stack_body('call_finished',"e->closure->ary[0]=a.closure->ary[0]; free(a.closure->ary); closures=a.closure-1; a.closure=e->closure;free(e);")
stack_body('call_conted',"#{revert_a('closure')} e->closure->ary[0]=a.closure->ary[0]; a.closure=e->closure;#{cont_call()}")

stack_def('nested_end',[])
stack_body('nested',"#{stack_push('nested_end')} #{push_exp('e->body')}")
stack_body('nested_end',"long st=r.state;r.state=0;if (st) {#{cont_call}} else { fail(); }")
stack_body('return',"#{revert_r('state')} r.state= e->state;")
%>

<%
File.open("defs.h",'w'){|f|
no=0;$argh.map{|n,_|no+=1; f.puts"#define TP_#{n} #{no}"}*""
}
%>

<%=$stackstructs*"" %>
void fail(){}

exp * call_conted(struct closure_s * c){
  exp_call_conted * e=calloc(sizeof(exp_call_conted),1);e->tp=TP_call_conted;
  e->forget=NULL;
  e->closure=c;
  return e;
}

static exp * finish;
void *match(exp *e,void *extra,Args a){
  Result r; Global gl;
  use_memo(&gl);
  r.state=0; gl.alternatives=0;
  gl.extra=extra;
  char *call_stack,*call_stack_start;
  call_stack_start=malloc(1000000);call_stack=call_stack_start+1000000;
  struct closure_s *closures = malloc(1000000*sizeof(struct closure_s)),*closures_start;closures_start=closures;
  struct cont_s    *conts    = malloc(1000000*sizeof(struct cont_s)),*conts_start   ;conts_start   =conts;  
  <%=push_exp("finish") %>
  <%=push_cont_exp("finish")%>
  <%=push_exp("e") %>
  while(1){
    if(call_stack<call_stack_start){printf("TODO grow stack");exit(42);}
    switch(*call_stack){
    <%=$stackbody*""%>
    }
  }
}

void *match2(exp *e,void *extra,char *s){
  Args a;
  struct closure_s *cl;
  cl=a.closure=calloc(sizeof(struct closure_s),1);
  a.closure->size=12;
  a.closure->ary=malloc(100);
  a.str=s;
  a.stops=0;
  void *r= match(e,extra,a);
  free(cl->ary);
  free(cl);
  return r;
}


void init_stack_machine(){
  finish=calloc(sizeof(exp_finish),1);finish->tp=TP_finish;

}
