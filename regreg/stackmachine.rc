<% require './types.rb' %>
#include "stackmachine.h"
<%=
   $nodes.map{|n,a|
              "
               exp *make_#{n}(#{a.map{|k,v| "#{k} #{v}"}*","}){exp_#{n} *e=malloc(sizeof(exp_#{n}));e->tp=TP_#{n}; #{a.map{|k,v|"e->#{v}=#{v};"}*""} return (exp *) e;}\n"
  }*""
%>
<%
  def push_exp(e)
    "*(exp **) stack_match =(exp *) #{e};stack_match += sizeof(exp *); *stack_match = #{e}->tp; stack_match+=1;"
  end 
  def push_cont(t,c)
    $revert<<"gl.stack_cont";$revert<<"a.cont"
    "gl.stack_cont->tp=#{t};gl.stack_cont->e=#{c};gl.stack_cont->previous=a.cont;  a.cont=gl.stack_cont; gl.stack_cont+=1;"
  end
  def cont_call
    "memcpy(stack_match,a.cont,st_siz);stack_match+=st_siz;a.cont=a.cont->previous;"
  end
%>

FILE *debug;
void *match(exp* e,void *extra,Args a){
  Result r; Global gl;
  gl.extra=extra;
  r.state=0;
  char   *stack_match=malloc(1000000);
  gl.stack_cont=malloc(1000000);
  char *o_stack_match=stack_match; t_cont *o_stack_cont=gl.stack_cont;
  stack_match+=st_siz; *(stack_match-1)=FINISH;
  a.cont=gl.stack_cont; gl.stack_cont->tp=FINISH;gl.stack_cont+=1;
  <%=push_exp("e")%>
  while(1){
      switch(*(stack_match-1)){
<%=
  def restore_a(sc,args)
  args.map{|t,v| "case RESTORE_#{sc}_#{v}:
      if (#{v=="closure" ? "1" : "0"}) fprintf(debug, \"restoring #{sc}.#{v}\\n\");
      stack_match-=sizeof(#{t})+1;
      #{sc}.#{v}=*(#{t}*)stack_match;
      break;
    "}*""
  end
  restore_a("a",$arg_tp)+
  restore_a("r",$res_tp)+
  restore_a("gl",$glob_tp)
 %> 
<%=
  $revert=[]
  def set(var)
    $revert<<var;var
  end
  def ecase(tp,body)
    "case TP_#{tp}: { stack_match-=st_siz;
          exp_#{tp} *e=*(exp_#{tp}**)stack_match;
          fprintf(debug, \"match \"); inspect_exp(e);fprintf(debug,\"\\n\");
          #{$revert.uniq.sort.map{|r| "SAVE_#{r.gsub(".","_")};"}*""}#{$revert=[];""}
          #{body}
          break;}"
  end

  ecase("seq","
              #{push_cont("e->tail->tp","e->tail")}
              #{push_exp("e->head")}")+
  ecase("char","
          
          fprintf(debug,\"character %s on %s\\n\",e->str,a.str);
          if (*#{set("a.str")}==*e->str){
            a.str+=1;
            #{cont_call()}
          } else FAIL;")+
  ecase("act","
          int i;for(i=0;i<e->varc;i++){
            fprintf(debug,\"saving %i %i\\n\",a.closure[e->vars[i]],e->vars[i]);
            *(void **)stack_match=a.closure[e->vars[i]];stack_match+=sizeof(void *);
            *(long *)stack_match =e->vars[i];           stack_match+=sizeof(long);
            *stack_match=bind_restore;                  stack_match+=1;
          }
          void*(*fn)() =e->fn;
          a.closure[0]=r.returned;
          fn(a.closure,gl.extra,e->arg);
          #{set("r.returned")}=a.closure[0];
          #{cont_call()}
  ")+
  ecase("stop","
          #{set("a.stops")}|=e->stops;
          #{cont_call()}")+
  ecase("make_lambda","
    lambda_s *l=malloc(sizeof(lambda_s));
    l->body=e->body;l->closure=a.closure;
    r.returned=(void *) l;
  ")+
  ecase("use_lambda","
    lambda_s *l=r.returned;
    #{set("a.closure")}=l->closure;
    #{push_exp("l->body")}
  ")+
  ecase("call","
    /*We currently do not garbage collect closures as they can be used by lambdas.
      There are several improvements possible depending on garbage collection.
      First is that we allocate closure on stack and maintain list of lambdas 
      constructed by current rule. When rule returns we copy closure to stack based 
      one and update lambda pointers. When we know that lambda is dead we can skip 
      constructing closure, but this depends on garbage collector/running analysis to 
      decide if this can happen.*/
    fprintf(debug,\"calling %s\\n\",e->name);
    #{push_cont("call_end","a.closure")};
    void **closure=malloc(sizeof(void*)*e->body->locals);
    int i;
    fprintf(debug,\"new closure %i\\n\",e->body->locals);
    for(i=0;i<e->argc;i++) closure[i+1]=a.closure[e->afrom[i]];    
    #{set("a.closure")}=closure;
    #{push_exp("e->body->body")}
  ")+
  ecase("nested","
    *stack_match=nested_end; stack_match+=1;
    #{push_exp("e->body")}
  ")+
  ecase("enter","
    #{set("a.str")}=r.returned;
    #{push_exp("e->to")}
  ")+
  ecase("bind","
    fprintf(debug,\"saving %i %i\\n\",a.closure[e->var],e->var);
    *(void **)stack_match=a.closure[e->var];stack_match+=sizeof(void *);
    *(long *)stack_match =e->var;           stack_match+=sizeof(long);
    *stack_match=bind_restore;              stack_match+=1;
    a.closure[e->var]=r.returned;
    #{cont_call()}
  ")+
  ecase("many","
         if (e->stops & a.stops){
           #{set("a.stops")}=a.stops&(~e->stops);
           #{cont_call()}
         }else{
           #{push_cont("e->tp","e")}
           #{push_exp("e->body")}
         }")+
  ecase("return","
    r.state= e->state;
  ")+
  ecase("switch","
                  #{push_exp("e")};*(stack_match-1)=switch2;
                  #{push_exp("e->head")};
")
%>
         case switch2:stack_match-=st_siz; exp_switch *e=*(exp_switch **)stack_match;
          if (e->alts[r.state]){
           <%=push_exp("e->alts[r.state]")%>
          }
           break;
         case bind_restore:stack_match-=sizeof(void*)+sizeof(long)+1;
           fprintf(debug,"restoring %i %i\n",*(void **)stack_match,*(long*)(stack_match+sizeof(void*)));
           a.closure[*(long*)(stack_match+sizeof(void*))]=*(void **)stack_match;
           break;
         case nested_end:
          stack_match-=1; 
          if (r.state) {
            <%=cont_call()%>
          } else {
            FAIL;
          }
          break;
         case call_end:
          stack_match-=sizeof(void**)+1;
          a.closure=*(void***) stack_match;
          <%= cont_call()%>
          break;
         case FINISH:
           free(o_stack_cont);
           free(o_stack_match);
           return r.returned;
       }
  }
}
void *match2(exp *e,void *extra,char *s){
  Args a;
  a.cont;
  a.closure=malloc(100);
  a.str=s;
  a.stops=0;
  return match(e,extra,a);
}

